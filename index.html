<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Demon's Contract Duel: Online</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Cinzel:wght@400;700&family=Noto+Serif+JP:wght@400;700&display=swap" rel="stylesheet">
    
    <!-- Â§ñÈÉ®Ë®≠ÂÆö„Éï„Ç°„Ç§„É´Ë™≠„ÅøËæº„ÅøÔºàÂ≠òÂú®„Åô„ÇãÂ†¥ÂêàÔºâ -->
    <script src="config.js" onerror="console.log('Local config.js not found, using manual/env config.')"></script>

    <!-- Firebase SDKs -->
    <script type="module">
        import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
        import { getAuth, signInAnonymously, onAuthStateChanged, signInWithCustomToken } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
        import { getFirestore, collection, doc, setDoc, getDoc, updateDoc, onSnapshot } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";

        window.firebaseApp = null;
        window.db = null;
        window.auth = null;
        window.myPlayerIndex = null;
        window.roomId = null;
        window.unsubscribeRoom = null;
        window.user = null;
        window.localState = { 
            lastTargetIdx: -1, 
            pendingCardIdx: null,
            lastBidSeen: -1,
            lastPlayTimestamp: 0,
            battleActionTaken: false 
        };

        const COLLECTION_NAME = 'demons_contract_rooms_v3'; 
        const appId = typeof __app_id !== 'undefined' ? __app_id : 'default-app-id';

        // ‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº
        const manualConfig = null;
        // ‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤

        async function initFirebase() {
            const statusEl = document.getElementById('lobby-status');
            try {
                let firebaseConfig;
                if (typeof window.FIREBASE_CONFIG !== 'undefined') {
                    firebaseConfig = window.FIREBASE_CONFIG;
                } else if (manualConfig) {
                    firebaseConfig = manualConfig;
                } else if (typeof __firebase_config !== 'undefined') {
                    firebaseConfig = JSON.parse(__firebase_config);
                } else {
                    throw new Error("Ë®≠ÂÆöÊú™ÂÆå‰∫Ü: config.js„Çí‰ΩúÊàê„Åô„Çã„Åã„Ç≥„Éº„ÉâÂÜÖ„ÅÆmanualConfig„ÇíÊõ∏„ÅçÊèõ„Åà„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ");
                }

                statusEl.innerText = "Connecting...";
                window.firebaseApp = initializeApp(firebaseConfig);
                window.auth = getAuth(window.firebaseApp);
                window.db = getFirestore(window.firebaseApp);

                if (typeof __initial_auth_token !== 'undefined' && __initial_auth_token) {
                    await signInWithCustomToken(window.auth, __initial_auth_token);
                } else {
                    await signInAnonymously(window.auth);
                }

                onAuthStateChanged(window.auth, (u) => {
                    if (u) {
                        window.user = u;
                        console.log("Logged in:", u.uid);
                        statusEl.innerText = "Ready";
                        statusEl.classList.add('text-green-500');
                        document.getElementById('create-room-btn').disabled = false;
                        document.getElementById('join-room-btn').disabled = false;
                    }
                });

            } catch (e) {
                console.error("Firebase Init Error", e);
                statusEl.innerText = "Error: " + e.message;
            }
        }

        // --- Room Logic ---
        window.createRoom = async function() {
            if (!window.user) return;
            const btn = document.getElementById('create-room-btn');
            btn.disabled = true; btn.innerText = "Creating...";

            try {
                const roomCode = Math.random().toString(36).substring(2, 8).toUpperCase();
                window.roomId = roomCode;
                window.myPlayerIndex = 0; // Host is P1

                initGameState(); 
                
                const roomRef = doc(window.db, 'artifacts', appId, 'public', 'data', COLLECTION_NAME, roomCode);
                await setDoc(roomRef, {
                    gameState: window.gameState,
                    players: [{uid: window.user.uid, name: "Player 1"}],
                    createdAt: Date.now(),
                    status: 'WAITING'
                });

                setupRoomListener(roomCode);
                document.getElementById('lobby-screen').classList.add('hidden');
                
                const waitingScreen = document.getElementById('waiting-screen');
                waitingScreen.classList.remove('hidden');
                void waitingScreen.offsetWidth; 
                waitingScreen.classList.add('active'); 
                
                const codeInput = document.getElementById('room-code-display');
                if(codeInput) codeInput.value = roomCode;

            } catch (e) {
                alert("‰ΩúÊàê„Ç®„É©„Éº: " + e.message);
                btn.disabled = false; btn.innerText = "Create Room";
            }
        }

        window.joinRoom = async function() {
            if (!window.user) return;
            const btn = document.getElementById('join-room-btn');
            btn.disabled = true; btn.innerText = "Joining...";

            try {
                const codeInput = document.getElementById('room-code-input').value.toUpperCase();
                if (!codeInput) throw new Error("Please enter a room code");

                const roomRef = doc(window.db, 'artifacts', appId, 'public', 'data', COLLECTION_NAME, codeInput);
                const snap = await getDoc(roomRef);

                if (!snap.exists()) throw new Error("Room not found");
                const data = snap.data();
                if (data.status !== 'WAITING') throw new Error("Room is full or playing");

                window.roomId = codeInput;
                window.myPlayerIndex = 1; // Guest is P2
                
                let updatedPlayers = [...data.players, {uid: window.user.uid, name: "Player 2"}];
                
                await updateDoc(roomRef, {
                    players: updatedPlayers,
                    status: 'PLAYING'
                });

                setupRoomListener(codeInput);
                document.getElementById('lobby-screen').classList.add('hidden');

            } catch (e) {
                alert("ÂèÇÂä†„Ç®„É©„Éº: " + e.message);
                btn.disabled = false; btn.innerText = "Join Room";
            }
        }
        
        window.copyRoomCode = function() {
            const codeInput = document.getElementById('room-code-display');
            if(!codeInput) return;
            codeInput.select();
            codeInput.setSelectionRange(0, 99999);
            try {
                navigator.clipboard.writeText(codeInput.value);
            } catch(err) {
                alert("Code: " + codeInput.value);
            }
        }

        function setupRoomListener(code) {
            const roomRef = doc(window.db, 'artifacts', appId, 'public', 'data', COLLECTION_NAME, code);
            window.unsubscribeRoom = onSnapshot(roomRef, (doc) => {
                if (doc.exists()) {
                    const data = doc.data();
                    if (data.gameState) {
                        // Detect turn change to reset local action state
                        if (window.gameState && window.gameState.battle.activePlayer !== data.gameState.battle.activePlayer) {
                            window.localState.battleActionTaken = false;
                        }
                        window.gameState = data.gameState;
                    }
                    if (data.status === 'PLAYING') {
                         const waiting = document.getElementById('waiting-screen');
                         if(!waiting.classList.contains('hidden')) {
                             waiting.classList.remove('active');
                             setTimeout(() => waiting.classList.add('hidden'), 500); 
                         }
                         render();
                    }
                }
            });
        }

        window.pushState = async function() {
            if (!window.roomId || !window.db) return;
            try {
                const roomRef = doc(window.db, 'artifacts', appId, 'public', 'data', COLLECTION_NAME, window.roomId);
                await updateDoc(roomRef, { gameState: window.gameState });
            } catch (e) { console.error("Sync Error:", e); }
        }

        // --- View Logic ---
        window.viewDiscard = function(playerIdx) {
            if (!window.gameState) return;
            const targetPlayer = window.gameState.players[playerIdx];
            const viewer = document.getElementById('discard-viewer');
            const container = document.getElementById('discard-cards-container');
            const title = document.getElementById('discard-title');
            
            let playerName = (playerIdx === window.myPlayerIndex) ? "„ÅÇ„Å™„Åü" : "Áõ∏Êâã";
            title.innerText = `${playerName} „ÅÆÊç®„Å¶Êú≠`;
            
            container.innerHTML = '';
            if (targetPlayer.discard.length === 0) {
                container.innerHTML = '<div class="text-gray-500 w-full text-center py-10">„Å™„Åó</div>';
            } else {
                targetPlayer.discard.forEach(card => {
                    container.innerHTML += createCardHTML(card, 'transform scale-90');
                });
            }
            
            viewer.classList.remove('hidden');
            viewer.classList.add('active');
        }

        window.closeDiscard = function() {
            const viewer = document.getElementById('discard-viewer');
            viewer.classList.remove('active');
            setTimeout(() => viewer.classList.add('hidden'), 200);
        }

        window.toggleMenu = function() {
            const menu = document.getElementById('game-menu');
            if (menu.classList.contains('hidden')) {
                menu.classList.remove('hidden');
                void menu.offsetWidth; // Force Reflow
                menu.classList.add('active');
            } else {
                menu.classList.remove('active');
                setTimeout(() => menu.classList.add('hidden'), 300);
            }
        }

        window.showCardList = function() {
            const viewer = document.getElementById('card-list-viewer');
            const container = document.getElementById('all-cards-container');
            container.innerHTML = '';
            
            const sortedCards = [...CARD_DB].sort((a, b) => a.cost - b.cost);
            sortedCards.forEach(card => {
                container.innerHTML += createCardHTML(card, 'transform scale-90');
            });
            
            viewer.classList.remove('hidden');
            void viewer.offsetWidth;
            viewer.classList.add('active');
            
            document.getElementById('game-menu').classList.remove('active');
            document.getElementById('game-menu').classList.add('hidden');
        }

        window.closeCardList = function() {
            const viewer = document.getElementById('card-list-viewer');
            viewer.classList.remove('active');
            setTimeout(() => viewer.classList.add('hidden'), 200);
        }

        window.surrenderGame = function() {
            if(!window.gameState || window.myPlayerIndex === null) return;
            if(!confirm("Êú¨ÂΩì„Å´ÈôçÂèÇ„Åó„Åæ„Åô„ÅãÔºü\n„Åì„ÅÆÊìç‰Ωú„ÅØÂèñ„ÇäÊ∂à„Åõ„Åæ„Åõ„Çì„ÄÇ")) return;
            
            const oppIdx = window.myPlayerIndex === 0 ? 1 : 0;
            const pName = window.gameState.players[window.myPlayerIndex].name;
            window.gameState.winner = oppIdx;
            window.gameState.winReason = "ÈôçÂèÇ";
            addLog(`${pName} „ÅåÈôçÂèÇ„Åó„Åæ„Åó„Åü`);
            window.pushState();
            window.toggleMenu();
        }

        window.showCardSelector = function(cards, callback) {
            const selector = document.getElementById('card-selector');
            const container = document.getElementById('selector-cards-container');
            container.innerHTML = '';
            
            if(cards.length === 0) {
                alert("ÂØæË±°„Åå„ÅÇ„Çä„Åæ„Åõ„Çì„ÄÇ");
                if(callback) callback(null);
                return;
            }

            cards.forEach((card, originalIndex) => {
                let wrapper = document.createElement('div');
                wrapper.innerHTML = createCardHTML(card, 'cursor-pointer hover:border-yellow-500 transform hover:scale-105 transition-all');
                wrapper.onclick = () => {
                    selector.classList.remove('active');
                    setTimeout(() => selector.classList.add('hidden'), 200);
                    callback(originalIndex);
                };
                container.appendChild(wrapper);
            });

            selector.classList.remove('hidden');
            void selector.offsetWidth;
            selector.classList.add('active');
        }

        window.closeSelector = function() {
            const selector = document.getElementById('card-selector');
            selector.classList.remove('active');
            setTimeout(() => selector.classList.add('hidden'), 200);
        }

        // --- Log & Cut-in ---
        function addLog(msg) {
            if (!window.gameState.logs) window.gameState.logs = [];
            const timestamp = new Date().toLocaleTimeString('ja-JP', { hour: '2-digit', minute: '2-digit', second: '2-digit' });
            window.gameState.logs.push(`[${timestamp}] ${msg}`);
            // Keep log size reasonable
            if (window.gameState.logs.length > 50) window.gameState.logs.shift();
        }

        function showCutIn(card, playerName) {
            const overlay = document.getElementById('cut-in-overlay');
            const container = document.getElementById('cut-in-card-container');
            const nameEl = document.getElementById('cut-in-player-name');
            
            nameEl.innerText = `${playerName} „ÅÆ‰ΩøÁî®`;
            container.innerHTML = createCardHTML(card, 'transform scale-150 shadow-2xl');
            
            overlay.classList.remove('hidden');
            void overlay.offsetWidth; 
            overlay.classList.add('active');
            
            setTimeout(() => {
                overlay.classList.remove('active');
                setTimeout(() => overlay.classList.add('hidden'), 300);
            }, 3000); // 3ÁßíÈñìË°®Á§∫
        }

        initFirebase();
    </script>
    
    <style>
        :root {
            --bg-color: #0f0f13;
            --card-bg: #1a1a20;
            --text-color: #e0e0e0;
            --accent-gold: #d4af37;
            --accent-red: #8a0303;
            --accent-blue: #1e3a5f;
            --accent-purple: #4a1e5f;
            --mana-blue: #00bfff;
        }

        body {
            background-color: var(--bg-color);
            color: var(--text-color);
            font-family: 'Noto Serif JP', serif;
            overflow-x: hidden;
            user-select: none;
        }

        h1, h2, h3, .cinzel { font-family: 'Cinzel', serif; }

        #bg-canvas { position: fixed; top: 0; left: 0; width: 100%; height: 100%; z-index: -1; opacity: 0.3; }

        /* Card */
        .card {
            width: 140px; height: 210px;
            background: var(--card-bg);
            border: 2px solid #333; border-radius: 8px;
            position: relative;
            transition: all 0.2s; cursor: pointer;
            overflow: hidden;
            display: flex; flex-direction: column; justify-content: space-between; padding: 6px;
            box-shadow: 0 4px 6px rgba(0,0,0,0.5);
        }
        .card:hover { transform: translateY(-10px) scale(1.05); z-index: 10; border-color: var(--accent-gold); }
        .card.disabled { opacity: 0.4; cursor: not-allowed; filter: grayscale(0.8); }

        .card-type-A { border-color: var(--accent-red); }
        .card-type-B { border-color: var(--accent-blue); }
        .card-type-C { border-color: var(--accent-purple); }
        .card-type-S { border-color: #555; }

        .card-cost {
            position: absolute; top: 4px; right: 4px;
            background: var(--mana-blue); color: #000;
            border-radius: 50%; width: 24px; height: 24px;
            display: flex; align-items: center; justify-content: center;
            font-weight: bold; font-size: 0.8rem; box-shadow: 0 0 5px var(--mana-blue);
        }

        .card-title { font-size: 0.85rem; font-weight: bold; text-align: center; margin-top: 14px; line-height: 1.1; }
        .card-art { flex-grow: 1; display: flex; align-items: center; justify-content: center; font-size: 1.8rem; }
        .card-desc { 
            font-size: 0.7rem; text-align: center; color: #ccc; 
            line-height: 1.3; min-height: 60px; padding: 4px;
            background: rgba(0,0,0,0.3); border-radius: 4px;
            display: flex; align-items: center; justify-content: center;
        }

        /* UI */
        .btn-gothic {
            background: linear-gradient(to bottom, #2a2a35, #1a1a20);
            border: 1px solid var(--accent-gold); color: var(--accent-gold);
            padding: 8px 16px; font-family: 'Cinzel', serif; text-transform: uppercase;
            cursor: pointer; transition: 0.2s;
        }
        .btn-gothic:hover:not(:disabled) { background: var(--accent-gold); color: #000; }
        .btn-gothic:disabled { opacity: 0.5; cursor: not-allowed; border-color: #555; color: #555; }

        .overlay {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.95); z-index: 50;
            display: flex; flex-direction: column; justify-content: center; align-items: center;
            transition: opacity 0.3s; opacity: 0; pointer-events: none;
        }
        .overlay.active { opacity: 1; pointer-events: all; }
        .hidden { display: none !important; }

        .mana-container { display: flex; gap: 2px; margin-top: 4px; justify-content: center; }
        .mana-pip { width: 12px; height: 12px; border-radius: 50%; background: #333; border: 1px solid #555; }
        .mana-pip.active { background: var(--mana-blue); border-color: #fff; box-shadow: 0 0 5px var(--mana-blue); }

        .damage-popup {
            position: absolute; color: #ff0000; font-weight: bold; font-size: 2rem;
            text-shadow: 2px 2px 0 #000; pointer-events: none; z-index: 100;
            animation: floatUp 1s ease-out forwards;
        }
        @keyframes floatUp { 0% { opacity: 1; transform: translateY(0); } 100% { opacity: 0; transform: translateY(-50px); } }
        
        .discard-grid, .selector-grid {
            display: grid; grid-template-columns: repeat(auto-fill, minmax(130px, 1fr));
            gap: 1rem; width: 80%; max-width: 800px; max-height: 70vh; overflow-y: auto; padding: 1rem;
        }

        /* Log Window - Moved to Right Top */
        #log-window {
            position: absolute; top: 70px; right: 10px; width: 220px; height: 180px;
            background: rgba(0, 0, 0, 0.7); border: 1px solid #555; border-radius: 4px;
            font-size: 0.7rem; color: #ccc; z-index: 40; pointer-events: auto;
            display: flex; flex-direction: column;
        }
        #log-header { background: #333; padding: 4px 8px; font-weight: bold; cursor: move; }
        #log-content { flex-grow: 1; overflow-y: auto; padding: 8px; display: flex; flex-direction: column-reverse; }
        .log-entry { margin-bottom: 4px; border-bottom: 1px solid #222; padding-bottom: 2px; }

        /* Cut-in Overlay */
        #cut-in-overlay {
            z-index: 300; background: rgba(0,0,0,0.85); /* Slightly darker */
            transition: all 0.3s ease-out; transform: scale(0.8); opacity: 0;
        }
        #cut-in-overlay.active { transform: scale(1); opacity: 1; }
        #cut-in-player-name {
            font-size: 3rem; color: var(--accent-gold); text-shadow: 0 0 20px black; 
            margin-bottom: 2rem; letter-spacing: 0.2rem;
        }
    </style>
</head>
<body class="h-screen flex flex-col">
    <canvas id="bg-canvas"></canvas>

    <!-- Lobby -->
    <div id="lobby-screen" class="overlay active" style="z-index: 100;">
        <div class="bg-gray-900 border border-yellow-600 p-8 rounded text-center w-80">
            <h1 class="text-2xl text-yellow-500 mb-4 cinzel">Demon's Contract</h1>
            <p id="lobby-status" class="text-xs text-gray-500 mb-4">Initializing...</p>
            <button id="create-room-btn" onclick="createRoom()" disabled class="btn-gothic w-full mb-4">Create Room</button>
            <input type="text" id="room-code-input" placeholder="Room Code" class="bg-black border border-gray-600 text-white p-2 w-full mb-2 text-center">
            <button id="join-room-btn" onclick="joinRoom()" disabled class="btn-gothic w-full">Join Room</button>
        </div>
    </div>

    <!-- Waiting -->
    <div id="waiting-screen" class="overlay hidden" style="z-index: 110;">
        <h2 class="text-2xl cinzel text-white mb-4">Waiting...</h2>
        <div class="flex gap-2 mb-4 items-center">
            <input type="text" id="room-code-display" readonly class="text-4xl text-yellow-500 bg-black border border-gray-600 p-4 rounded text-center w-64 font-bold tracking-widest">
            <button onclick="copyRoomCode()" class="btn-gothic h-full text-2xl">üìã</button>
        </div>
        <p class="text-gray-500 text-xs">Waiting for Player 2 to join...</p>
    </div>

    <!-- Game Menu Overlay -->
    <div id="game-menu" class="overlay hidden" style="z-index: 200;">
        <div class="bg-gray-900 border border-yellow-600 p-8 rounded text-center w-80 flex flex-col gap-4">
            <h2 class="text-2xl text-yellow-500 cinzel">MENU</h2>
            <button onclick="showCardList()" class="btn-gothic w-full">üìñ CARD LIST</button>
            <button onclick="surrenderGame()" class="btn-gothic w-full border-red-500 text-red-500 hover:bg-red-900/30">üè≥Ô∏è SURRENDER</button>
            <div class="h-px bg-gray-700 my-2"></div>
            <button onclick="toggleMenu()" class="btn-gothic w-full border-gray-500 text-gray-400">CLOSE</button>
        </div>
    </div>

    <!-- Card List Viewer -->
    <div id="card-list-viewer" class="overlay hidden" style="z-index: 210;">
        <h2 class="text-2xl text-yellow-500 mb-4 cinzel">ALL CARDS</h2>
        <div id="all-cards-container" class="discard-grid"></div>
        <button onclick="closeCardList()" class="btn-gothic mt-4">CLOSE</button>
    </div>

    <!-- Discard Viewer -->
    <div id="discard-viewer" class="overlay hidden" style="z-index: 120;">
        <h2 id="discard-title" class="text-2xl text-yellow-500 mb-4 cinzel">DISCARD PILE</h2>
        <div id="discard-cards-container" class="discard-grid"></div>
        <button onclick="closeDiscard()" class="btn-gothic mt-4">CLOSE</button>
    </div>

    <!-- Card Selector (Purge) -->
    <div id="card-selector" class="overlay hidden" style="z-index: 130;">
        <h2 class="text-2xl text-yellow-500 mb-4 cinzel">SELECT A CARD TO PURGE</h2>
        <p class="text-gray-400 mb-4 text-sm">Choose a card from your discard pile to remove from the game.</p>
        <div id="selector-cards-container" class="selector-grid"></div>
        <button onclick="closeSelector()" class="btn-gothic mt-4 text-gray-500 border-gray-500">CANCEL</button>
    </div>

    <!-- Cut-in Overlay -->
    <div id="cut-in-overlay" class="overlay hidden">
        <h2 id="cut-in-player-name" class="cinzel font-bold">PLAYER PLAYS</h2>
        <div id="cut-in-card-container"></div>
    </div>

    <!-- Game UI -->
    <header class="h-12 bg-black/80 flex justify-between items-center px-4 border-b border-gray-800">
        <div class="flex items-center gap-4">
            <span id="round-indicator" class="text-yellow-500 cinzel font-bold">ROUND 1</span>
            <span id="phase-display" class="text-xs text-gray-400">PHASE</span>
        </div>
        <div class="flex items-center gap-4">
            <div class="text-xs text-gray-500" id="player-role-display">Observer</div>
            <button onclick="toggleMenu()" class="btn-gothic px-2 py-1 text-xl leading-none">‚öôÔ∏è</button>
        </div>
    </header>

    <main class="flex-grow flex flex-col relative p-2 overflow-hidden">
        
        <!-- Log Window (Position Changed) -->
        <div id="log-window">
            <div id="log-header">BATTLE LOG</div>
            <div id="log-content"></div>
        </div>

        <!-- Opponent -->
        <div class="h-1/4 flex justify-between items-start px-4">
            <div class="flex flex-col items-center">
                <div class="text-xs text-gray-500">LIFE</div>
                <div id="p2-life" class="text-3xl text-red-500 cinzel">66</div>
                <div id="p2-mana" class="mana-container"></div>
                <div id="p2-shield" class="text-blue-400 text-xs mt-1"></div>
            </div>
            <div class="flex gap-2">
                <div class="w-16 h-24 bg-gray-800 border border-gray-600 rounded flex items-center justify-center text-xs text-gray-500">Deck <span id="p2-deck-count" class="ml-1 text-white">0</span></div>
                <div class="w-16 h-24 bg-gray-800 border border-gray-600 rounded flex items-center justify-center text-xs text-gray-500 cursor-pointer hover:border-white transition-colors" onclick="viewDiscard(window.myPlayerIndex === 0 ? 1 : 0)">
                    Disc
                </div>
            </div>
        </div>

        <!-- Center (Market & Bidding) -->
        <div class="flex-grow flex justify-center items-center relative">
            <div id="market-area" class="flex gap-4 z-10 transition-all"></div>

            <!-- Bidding UI -->
            <div id="bidding-ui" class="absolute bg-black/90 border border-yellow-600 p-4 rounded z-20 flex hidden w-[500px]">
                <div class="flex-1 flex flex-col items-center gap-2 pr-4 border-r border-gray-700">
                    <div class="text-yellow-500 cinzel">BIDDING</div>
                    <div class="flex w-full justify-between items-center text-sm text-gray-300">
                        <span>Current High: <span id="bid-current-val" class="text-white font-bold text-xl">0</span></span>
                    </div>
                    <div class="text-xs text-red-400 mb-2" id="bid-highest-player">-</div>
                    
                    <div id="bid-controls" class="w-full">
                        <div class="flex justify-center items-center gap-4 my-2">
                            <button onclick="adjustBid(-1)" class="btn-gothic px-2 py-0">-</button>
                            <span id="player-bid-val" class="text-2xl font-bold text-white">1</span>
                            <button onclick="adjustBid(1)" class="btn-gothic px-2 py-0">+</button>
                        </div>
                        <div class="flex gap-2 justify-center">
                            <button onclick="submitBid()" class="btn-gothic bg-red-900/50">BID</button>
                            <button onclick="passBid()" class="btn-gothic border-gray-600 text-gray-400">PASS</button>
                        </div>
                        <div class="text-xs text-gray-500 mt-2 text-center">Max Bid: Life - 1</div>
                    </div>
                    <div id="bid-waiting-msg" class="text-xs text-yellow-500 animate-pulse hidden">Waiting...</div>
                </div>

                <div class="flex-1 flex flex-col items-center justify-center pl-4">
                    <div class="text-xs text-gray-400 mb-1">Target Card</div>
                    <div id="bid-card-preview" class="scale-90 origin-top"></div>
                </div>
            </div>

            <!-- Battle Turn Indicator -->
            <div id="battle-ui" class="absolute bottom-4 z-20 hidden">
                <button id="end-turn-btn" onclick="endBattlePhase()" class="btn-gothic bg-blue-900/50 text-white px-8 py-2">END TURN</button>
            </div>
            <div id="wait-banner" class="absolute bottom-12 bg-black/80 px-4 py-1 rounded text-gray-400 text-sm hidden">Opponent's Turn</div>
        </div>

        <!-- Player -->
        <div class="h-1/3 flex justify-between items-end px-4 pb-2 bg-gradient-to-t from-black/80 to-transparent">
            <div class="flex flex-col items-center">
                <div class="text-xs text-gray-500">LIFE</div>
                <div id="p1-life" class="text-3xl text-red-500 cinzel">66</div>
                <div id="p1-mana" class="mana-container"></div>
                <div id="p1-shield" class="text-blue-400 text-xs mt-1"></div>
            </div>
            
            <div class="flex gap-4 items-end">
                <div class="flex flex-col items-center">
                    <div id="p1-hand" class="flex gap-2 mb-2 justify-center"></div>
                    <div class="text-xs text-gray-500">HAND</div>
                </div>
                <div class="flex gap-2">
                    <div class="w-16 h-24 bg-gray-800 border border-gray-600 rounded flex items-center justify-center text-xs text-gray-500 relative">Deck <span id="p1-deck-count" class="absolute -top-2 -right-2 bg-blue-600 text-white rounded-full w-5 h-5 flex items-center justify-center">0</span></div>
                    <div class="w-16 h-24 bg-gray-800 border border-gray-600 rounded flex items-center justify-center text-xs text-gray-500 cursor-pointer hover:border-white transition-colors" onclick="viewDiscard(window.myPlayerIndex)">
                        Disc
                    </div>
                </div>
            </div>
        </div>
    </main>

    <!-- Game Over -->
    <div id="game-over-overlay" class="overlay hidden" style="z-index: 200;">
        <h2 id="winner-text" class="text-4xl text-yellow-500 mb-4 cinzel">WINNER</h2>
        <p id="win-reason" class="text-gray-400 mb-8">Reason</p>
        <button onclick="location.reload()" class="btn-gothic">BACK TO LOBBY</button>
    </div>

    <script>
        // --- CONSTANTS & CARD DB (Updated IDs) ---
        const CONSTANTS = { MAX_ROUNDS: 10, INITIAL_LIFE: 66, INITIAL_HAND: 3 };

        const CARD_DB = [
            // Starter
            { id: 'S-1', type: 'S', name: 'ÁîüË¥Ñ„ÅÆË°Ä', cost: 0, text: 'Áõ∏Êâã„Å´1„ÉÄ„É°„Éº„Ç∏„Çí‰∏é„Åà„Çã„ÄÇ', power: 1, selfDmg: 0, effect: 'dmg' },
            { id: 'S-2', type: 'S', name: 'ÂæÆÂº±„Å™È≠îÂäõ', cost: 1, text: '„Ç´„Éº„Éâ„Çí1ÊûöÂºï„Åè„ÄÇËá™Ë∫´„ÅÆ„É©„Ç§„Éï„Çí1Â§±„ÅÜ„ÄÇ', power: 0, selfDmg: 1, effect: 'draw' },
            // A - Attack
            { id: 'A-1', type: 'A', name: 'ÂÑÄÂºè„ÅÆÁü≠Ââ£', cost: 1, text: 'Áõ∏Êâã„Å´2„ÉÄ„É°„Éº„Ç∏„Çí‰∏é„Åà„Çã„ÄÇ', power: 2, selfDmg: 0, effect: 'dmg' },
            { id: 'A-2', type: 'A', name: 'È≠îÂäõÈõÜ‰∏≠', cost: 2, text: '„Ç´„Éº„Éâ„Çí1ÊûöÂºï„Åè„ÄÇÁõ∏Êâã„Å´2„ÉÄ„É°„Éº„Ç∏„Çí‰∏é„Åà„Çã„ÄÇ', power: 2, selfDmg: 0, effect: 'dmg_draw' },
            { id: 'A-3', type: 'A', name: 'ÊµÑÂåñ„ÅÆÁÅ´', cost: 3, text: 'Áõ∏Êâã„Å´3„ÉÄ„É°„Éº„Ç∏„Çí‰∏é„Åà„Çã„ÄÇÊç®„Å¶Êú≠„Å´„ÅÇ„ÇãS„Ç´„Éº„Éâ„Çí1ÊûöÈô§Â§ñ„Åô„Çã„ÄÇ', power: 3, selfDmg: 0, effect: 'dmg_purge' },
            { id: 'A-4', type: 'A', name: 'Âº∑Ê¨≤„ÅÆÂâ£', cost: 4, text: '„Ç´„Éº„Éâ„Çí1ÊûöÂºï„Åè„ÄÇÁõ∏Êâã„Å´5„ÉÄ„É°„Éº„Ç∏„Çí‰∏é„Åà„Çã„ÄÇ', power: 5, selfDmg: 0, effect: 'dmg_draw' },
            { id: 'A-5', type: 'A', name: 'ÈÄ£Èéñ„ÅÆÂë™„ÅÑ', cost: 4, text: 'Áõ∏Êâã„Å´3„ÉÄ„É°„Éº„Ç∏„Çí‰∏é„Åà„Çã„ÄÇ‰ΩøÁî®Âæå„ÄÅÊç®„Å¶Êú≠„Åß„ÅØ„Å™„ÅèÂ±±Êú≠„ÅÆ‰∏ã„Å´Êàª„Çã„ÄÇ', power: 3, selfDmg: 0, effect: 'dmg_recycle' },
            { id: 'A-6', type: 'A', name: 'È≠Ç„ÅÆÂê∏Âèé', cost: 6, text: 'Áõ∏Êâã„Å´7„ÉÄ„É°„Éº„Ç∏„Çí‰∏é„Åà„Çã„ÄÇËá™Ë∫´„ÅÆ„É©„Ç§„Éï„Çí3ÂõûÂæ©„Åô„Çã„ÄÇ', power: 7, selfDmg: 0, effect: 'dmg_heal', val: 3 },
            { id: 'A-7', type: 'A', name: 'ÊÇ™È≠î„ÅÆÂ•ëÁ¥Ñ', cost: 9, text: 'Áõ∏Êâã„Å´30„ÉÄ„É°„Éº„Ç∏„Çí‰∏é„Åà„Çã„ÄÇËá™Ë∫´„ÅÆ„É©„Ç§„Éï„Çí30Â§±„ÅÜ„ÄÇ', power: 30, selfDmg: 30, effect: 'dmg' },
            // B - Defense
            { id: 'B-1', type: 'B', name: 'Áû¨Èñì‰øÆÂæ©', cost: 1, text: 'Ëá™Ë∫´„ÅÆ„É©„Ç§„Éï„Çí2ÂõûÂæ©„Åô„Çã„ÄÇ', power: 0, selfDmg: 0, effect: 'heal', val: 2 },
            { id: 'B-2', type: 'B', name: 'È≠Ç„ÅÆËß£Êîæ', cost: 2, text: 'Ëá™Ë∫´„ÅÆ„É©„Ç§„Éï„Çí2ÂõûÂæ©„Åô„Çã„ÄÇÊâãÊú≠„Çí1ÊûöÈÅ∏„Å≥Èô§Â§ñ„Åô„Çã„ÄÇ', power: 0, selfDmg: 0, effect: 'heal_banish', val: 2 },
            { id: 'B-3', type: 'B', name: 'Áôí„ÇÑ„Åó„ÅÆÂàªÂç∞', cost: 3, text: 'Ëá™Ë∫´„ÅÆ„É©„Ç§„Éï„Çí5ÂõûÂæ©„Åô„Çã„ÄÇ', power: 0, selfDmg: 0, effect: 'heal', val: 5 },
            { id: 'B-4', type: 'B', name: 'Èò≤Âæ°„ÅÆÁµêÁïå', cost: 5, text: 'Ê¨°„Å´Âèó„Åë„Çã„ÉÄ„É°„Éº„Ç∏„Çí1Âõû„Å†„ÅëÁÑ°ÂäπÂåñ„Åô„Çã„ÄÇ', power: 0, selfDmg: 0, effect: 'nullify' },
            { id: 'B-5', type: 'B', name: 'ÂèçÂ∞Ñ„ÅÆÈè°', cost: 7, text: 'Ê¨°„Å´Âèó„Åë„Çã„ÉÄ„É°„Éº„Ç∏„ÇíÁÑ°ÂäπÂåñ„Åó„ÄÅ„Åù„ÅÆ„ÉÄ„É°„Éº„Ç∏„ÇíÁõ∏Êâã„Å´‰∏é„Åà„Çã„ÄÇ', power: 0, selfDmg: 0, effect: 'reflect' },
            // C - Control
            { id: 'C-1', type: 'C', name: 'È≠îÂäõ„ÅÆÊπßÂá∫', cost: 0, text: '„Åì„ÅÆ„Çø„Éº„É≥„ÅÆ„Åø„Éû„Éä+2„ÄÇ‰ΩøÁî®Âæå„ÄÅ„Åì„ÅÆ„Ç´„Éº„Éâ„ÅØ„Ç≤„Éº„É†„Åã„ÇâÈô§Â§ñ„Åï„Çå„Çã„ÄÇ', power: 0, selfDmg: 0, effect: 'mana_boost', val: 2, banish: true },
            { id: 'C-2', type: 'C', name: 'Êú™Êù•„ÅÆË¶ñÁ∑ö', cost: 1, text: 'Â±±Êú≠„ÅÆ‰∏ä„Åã„Çâ3Êûö„ÇíË¶ã„Å¶„ÄÅÂ•Ω„Åç„Å™È†ÜÁï™„ÅßÊàª„Åô„ÄÇÔºàÊú™ÂÆüË£ÖÔºö„Ç∑„É£„ÉÉ„Éï„É´Ôºâ', power: 0, selfDmg: 0, effect: 'scry' },
            { id: 'C-3', type: 'C', name: 'Áü•Ë≠ò„ÅÆË≠≤Ê∏°', cost: 3, text: '„Ç´„Éº„Éâ„Çí2ÊûöÂºï„Åè„ÄÇ', power: 0, selfDmg: 0, effect: 'draw_2' },
            { id: 'C-4', type: 'C', name: 'ÊôÇ„ÅÆÁ†Ç', cost: 5, text: 'Êç®„Å¶Êú≠„ÅÆS„Ç´„Éº„Éâ„ÇíÂÖ®„Å¶Èô§Â§ñ„Åó„ÅüÂæå„ÄÅÊç®„Å¶Êú≠„ÇíÂ±±Êú≠„Å´Êàª„Åó„Ç∑„É£„ÉÉ„Éï„É´„Åô„Çã„ÄÇ1ÊûöÂºï„Åè„ÄÇ', power: 0, selfDmg: 0, effect: 'reshuffle_draw' },
            { id: 'C-5', type: 'C', name: 'Â§©‰Ωø„ÅÆÂØµÊÑõ', cost: 10, text: '„ÄêÁâπÊÆäÂãùÂà©„Äë„Åì„ÅÆ„Ç≤„Éº„É†„Å´ÂãùÂà©„Åô„Çã„ÄÇ', power: 0, selfDmg: 0, effect: 'win' }
        ];

        // --- Game State Structure ---
        window.gameState = {
            round: 1,
            phase: 'MARKET', 
            players: [], 
            market: [],
            contractDeck: [],
            bidding: { targetIdx: 0, currentBid: 0, highestBidder: null, turn: 0, passCount: 0, starter: 0 },
            battle: { activePlayer: 0, passCount: 0 }, // Changed structure
            winner: null,
            winReason: null,
            logs: [],
            latestPlay: { cardId: null, player: null, timestamp: 0 }
        };

        // --- Logic ---
        function initGameState() {
            let deck = [];
            CARD_DB.forEach(c => {
                if(c.type !== 'S') {
                    deck.push({...c, uuid: crypto.randomUUID()});
                    deck.push({...c, uuid: crypto.randomUUID()});
                }
            });
            window.gameState.contractDeck = shuffle(deck);

            window.gameState.players = [0, 1].map(id => ({
                id, name: `Player ${id+1}`,
                life: CONSTANTS.INITIAL_LIFE,
                mana: 1, maxMana: 1,
                deck: [], hand: [], discard: [],
                shield: 0, nullify: false, reflect: false
            }));

            window.gameState.players.forEach(p => {
                let starters = [];
                for(let i=0; i<3; i++) starters.push({...CARD_DB[0], uuid: crypto.randomUUID()});
                for(let i=0; i<2; i++) starters.push({...CARD_DB[1], uuid: crypto.randomUUID()});
                p.deck = shuffle(starters);
                drawCards(p, CONSTANTS.INITIAL_HAND);
            });

            window.gameState.winner = null;
            window.gameState.winReason = null;
            window.gameState.logs = [];
            window.gameState.latestPlay = { cardId: null, player: null, timestamp: 0 };

            startRound();
        }

        function startRound() {
            window.gameState.phase = 'MARKET';
            window.gameState.market = [];
            for(let i=0; i<3; i++) {
                if(window.gameState.contractDeck.length > 0) window.gameState.market.push(window.gameState.contractDeck.pop());
            }
            
            let mana = window.gameState.round;
            if(mana > 10) mana = 10;
            window.gameState.players.forEach(p => {
                p.maxMana = mana;
                p.mana = mana;
            });

            addLog(`=== ROUND ${window.gameState.round} STARTED ===`);

            setTimeout(() => {
                // Draft bidding start rotates by round
                startBidding(0, (window.gameState.round % 2 !== 0) ? 0 : 1);
            }, 1000);
        }

        function startBidding(cardIdx, starterIdx) {
            if (cardIdx >= window.gameState.market.length) {
                startBattlePhase();
                return;
            }
            window.gameState.phase = 'BIDDING';
            window.gameState.bidding = {
                targetIdx: cardIdx,
                currentBid: 0,
                highestBidder: null,
                turn: starterIdx,
                passCount: 0,
                starter: starterIdx
            };
            const targetName = window.gameState.market[cardIdx]?.name || "Unknown";
            addLog(`Bidding started for: ${targetName} (Starter: Player ${starterIdx + 1})`);
            window.pushState();
        }

        // --- Interaction ---
        function checkMyTurn(context) {
            if (window.myPlayerIndex === null) return false;
            if (context === 'BID') return window.gameState.phase === 'BIDDING' && window.gameState.bidding.turn === window.myPlayerIndex;
            if (context === 'BATTLE') return window.gameState.phase === 'BATTLE' && window.gameState.battle.activePlayer === window.myPlayerIndex;
            return false;
        }

        function adjustBid(delta) {
            if (!checkMyTurn('BID')) return;
            const el = document.getElementById('player-bid-val');
            let val = parseInt(el.innerText) + delta;
            
            let min = window.gameState.bidding.currentBid + 1;
            if (val < min) val = min;
            
            const me = window.gameState.players[window.myPlayerIndex];
            let maxBid = Math.max(1, me.life - 1); 
            if (val > maxBid) val = maxBid;
            
            el.innerText = val;
        }

        function resolveBid(winnerIdx, cost) {
            const winner = window.gameState.players[winnerIdx];
            const card = window.gameState.market[window.gameState.bidding.targetIdx];
            
            winner.life -= cost;
            winner.discard.push(card); 
            
            addLog(`${winner.name} won ${card.name} for ${cost} life.`);

            let nextStarter = (winnerIdx === 0) ? 1 : 0;
            let nextIdx = window.gameState.bidding.targetIdx + 1;
            startBidding(nextIdx, nextStarter);
        }

        function submitBid() {
            if (!checkMyTurn('BID')) return;
            const val = parseInt(document.getElementById('player-bid-val').innerText);
            
            const me = window.gameState.players[window.myPlayerIndex];
            if (val >= me.life) {
                alert("Bid too high! Must have 1 life remaining.");
                return;
            }

            if (window.gameState.bidding.passCount > 0) {
                resolveBid(window.myPlayerIndex, val);
                return;
            }

            window.gameState.bidding.currentBid = val;
            window.gameState.bidding.highestBidder = window.myPlayerIndex;
            window.gameState.bidding.turn = (window.myPlayerIndex === 0) ? 1 : 0;
            window.gameState.bidding.passCount = 0;
            
            addLog(`${me.name} bids ${val}.`);
            window.pushState();
        }

        function passBid() {
            if (!checkMyTurn('BID')) return;
            
            const me = window.gameState.players[window.myPlayerIndex];
            addLog(`${me.name} passes.`);

            if (window.gameState.bidding.highestBidder !== null) {
                resolveBid(window.gameState.bidding.highestBidder, window.gameState.bidding.currentBid);
            } else {
                window.gameState.bidding.passCount = (window.gameState.bidding.passCount || 0) + 1;
                
                if (window.gameState.bidding.passCount >= 2) {
                    addLog("Both passed. Card discarded.");
                    let roundOwner = (window.gameState.round % 2 !== 0) ? 0 : 1; 
                    let nextIdx = window.gameState.bidding.targetIdx + 1;
                    startBidding(nextIdx, roundOwner);
                } else {
                    window.gameState.bidding.turn = (window.myPlayerIndex === 0) ? 1 : 0;
                    window.pushState();
                }
            }
        }

        function startBattlePhase() {
            window.gameState.phase = 'BATTLE';
            // „Äê‰øÆÊ≠£„Äë„Éê„Éà„É´„Éï„Çß„Ç§„Ç∫„ÅÆÈñãÂßã„ÅØÂ∏∏„Å´ Player 1
            window.gameState.battle.activePlayer = 0;
            window.gameState.battle.passCount = 0; 
            addLog("=== BATTLE PHASE START ===");
            window.pushState();
        }

        function playCard(cardIdx, purgeTargetIdx = null) {
            if (!checkMyTurn('BATTLE')) return;
            const pIdx = window.myPlayerIndex;
            const player = window.gameState.players[pIdx];
            const card = player.hand[cardIdx];
            const oppIdx = (pIdx === 0) ? 1 : 0;
            const opp = window.gameState.players[oppIdx];

            if (card.id === 'A-3' && purgeTargetIdx === null) {
                const sCards = player.discard.map((c, i) => ({...c, originalIdx: i})).filter(c => c.type === 'S');
                if (sCards.length > 0) {
                    window.localState.pendingCardIdx = cardIdx;
                    showCardSelector(sCards, (selectedIndex) => {
                        if (selectedIndex !== null) playCard(cardIdx, selectedIndex);
                    });
                    return; 
                }
            }

            if (player.mana < card.cost) {
                alert("Not enough Mana!");
                return;
            }

            addLog(`${player.name} plays ${card.name}`);
            window.gameState.latestPlay = { card, player: player.name, timestamp: Date.now() };

            window.gameState.battle.passCount = 0;
            window.localState.battleActionTaken = true; 

            player.mana -= card.cost;
            let dmg = card.power;
            
            if (card.selfDmg > 0) player.life -= card.selfDmg;

            if (card.effect === 'win') {
                window.gameState.winner = pIdx;
                window.gameState.winReason = "Angel's Favor";
            }

            if (card.effect.includes('dmg')) {
                if (opp.reflect) {
                    player.life -= dmg; 
                    opp.reflect = false;
                    dmg = 0;
                    addLog(`Damage reflected!`);
                } else if (opp.nullify) {
                    dmg = 0;
                    opp.nullify = false;
                    addLog(`Damage nullified!`);
                } else {
                    if (opp.shield > 0) {
                        let blocked = Math.min(opp.shield, dmg);
                        opp.shield -= blocked;
                        dmg -= blocked;
                    }
                    if (dmg > 0) opp.life -= dmg;
                }
            }

            if (card.effect.includes('draw')) {
                let n = (card.effect === 'draw_2') ? 2 : 1;
                drawCards(player, n);
            }
            
            if (card.effect.includes('heal')) {
                let heal = card.val || 0;
                player.life += heal;
            }

            if (card.effect === 'nullify') player.nullify = true;
            if (card.effect === 'reflect') player.reflect = true;
            if (card.effect === 'mana_boost') player.mana += card.val;
            
            if (card.id === 'A-3' && purgeTargetIdx !== null) {
                player.discard.splice(purgeTargetIdx, 1);
                addLog(`Purged a card from discard.`);
            }
            
            if (card.effect === 'reshuffle_draw') {
                player.discard = player.discard.filter(c => c.type !== 'S');
                player.deck = player.deck.concat(player.discard);
                player.discard = [];
                player.deck = shuffle(player.deck);
                drawCards(player, 1);
                addLog(`Reshuffled discard into deck.`);
            }

            if (card.effect === 'scry') { }

            player.hand.splice(cardIdx, 1);
            
            if (card.banish) {
                addLog(`${card.name} was banished.`);
            } else if (card.effect === 'dmg_recycle') {
                player.deck.unshift(card);
            } else {
                player.discard.push(card);
            }

            render(); 
            window.pushState();
        }

        function endBattlePhase() {
            if (!checkMyTurn('BATTLE')) return;
            
            const currentActor = window.gameState.battle.activePlayer;
            
            if (!window.localState.battleActionTaken) {
                window.gameState.battle.passCount += 1;
                addLog(`${window.gameState.players[window.myPlayerIndex].name} passes.`);
            } else {
                window.gameState.battle.passCount = 0; 
                addLog(`${window.gameState.players[window.myPlayerIndex].name} ends turn.`);
            }

            if (window.gameState.battle.passCount >= 2) {
                addLog("Both passed. End of Battle Phase.");
                endRound();
                return;
            }

            // „Äê‰øÆÊ≠£„ÄëÂ∏∏„Å´ 0 -> 1 -> 0 -> ... „Å®‰∫§‰ª£
            window.gameState.battle.activePlayer = (currentActor === 0) ? 1 : 0;
            
            window.localState.battleActionTaken = false; 
            
            window.pushState();
        }

        function endRound() {
            window.gameState.players.forEach(p => {
                p.discard = p.discard.concat(p.hand);
                p.hand = [];
                p.shield = 0; p.nullify = false; p.reflect = false;
                drawCards(p, CONSTANTS.INITIAL_HAND);
            });
            window.gameState.round++;
            if (window.gameState.round > CONSTANTS.MAX_ROUNDS) {
                let p1 = window.gameState.players[0];
                let p2 = window.gameState.players[1];
                if(p1.life > p2.life) forceEndGame("Player 1", "Time Limit");
                else forceEndGame("Player 2", "Time Limit");
                return;
            } else {
                startRound();
            }
        }

        // --- Utils ---
        function addLog(msg) {
            if (!window.gameState.logs) window.gameState.logs = [];
            const ts = new Date().toTimeString().split(' ')[0];
            window.gameState.logs.push(`[${ts}] ${msg}`);
            if (window.gameState.logs.length > 50) window.gameState.logs.shift();
        }

        function drawCards(p, n) {
            for(let i=0; i<n; i++) {
                if (p.deck.length === 0) {
                    if (p.discard.length === 0) break;
                    p.deck = shuffle(p.discard);
                    p.discard = [];
                }
                p.hand.push(p.deck.pop());
            }
        }
        function shuffle(arr) { return arr.sort(() => Math.random() - 0.5); }
        
        function forceEndGame(winner, reason) {
            window.gameState.winReason = reason;
            if(winner === "Player 1") window.gameState.winner = 0;
            else window.gameState.winner = 1;
            startRound(); 
        }

        // --- Render ---
        function render() {
            if (!window.gameState || window.myPlayerIndex === null) return;
            const me = window.gameState.players[window.myPlayerIndex];
            const opp = window.gameState.players[window.myPlayerIndex === 0 ? 1 : 0];

            document.getElementById('player-role-display').innerText = `You: ${me.name}`;
            document.getElementById('round-indicator').innerText = `ROUND ${window.gameState.round}`;
            document.getElementById('phase-display').innerText = window.gameState.phase;

            // Logs
            const logContent = document.getElementById('log-content');
            if (window.gameState.logs) {
                logContent.innerHTML = window.gameState.logs.slice().reverse().map(l => `<div class="log-entry">${l}</div>`).join('');
            }

            // Cut-in Check
            if (window.gameState.latestPlay && window.gameState.latestPlay.timestamp > window.localState.lastPlayTimestamp) {
                window.localState.lastPlayTimestamp = window.gameState.latestPlay.timestamp;
                showCutIn(window.gameState.latestPlay.card, window.gameState.latestPlay.player);
            }

            // Stats
            document.getElementById('p1-life').innerText = me.life;
            document.getElementById('p2-life').innerText = opp.life;
            renderMana('p1-mana', me.mana, me.maxMana);
            renderMana('p2-mana', opp.mana, opp.maxMana);
            
            document.getElementById('p1-deck-count').innerText = me.deck.length;
            document.getElementById('p2-deck-count').innerText = opp.deck.length;

            // --- Market Render ---
            const mArea = document.getElementById('market-area');
            mArea.innerHTML = '';
            
            if (window.gameState.phase !== 'BATTLE') {
                window.gameState.market.forEach((c, i) => {
                    let isTarget = (window.gameState.phase === 'BIDDING' && window.gameState.bidding.targetIdx === i);
                    let opacity = (window.gameState.phase === 'BIDDING' && !isTarget) ? 'opacity-30' : '';
                    let border = isTarget ? 'border-yellow-500 shadow-lg shadow-yellow-500/50' : '';
                    mArea.innerHTML += createCardHTML(c, `${opacity} ${border}`);
                });
            }

            // Bidding UI
            const bidUI = document.getElementById('bidding-ui');
            const isMyBidTurn = (window.gameState.phase === 'BIDDING' && window.gameState.bidding.turn === window.myPlayerIndex);
            
            if (window.gameState.phase === 'BIDDING') {
                bidUI.classList.remove('hidden');
                bidUI.classList.add('flex');
                
                const targetCard = window.gameState.market[window.gameState.bidding.targetIdx];
                if(targetCard) {
                    document.getElementById('bid-card-preview').innerHTML = createCardHTML(targetCard, '', '');
                }

                const currentBid = window.gameState.bidding.currentBid;
                document.getElementById('bid-current-val').innerText = currentBid;
                let highest = window.gameState.bidding.highestBidder;
                document.getElementById('bid-highest-player').innerText = highest === null ? "None" : (highest === window.myPlayerIndex ? "YOU" : "OPPONENT");

                if (isMyBidTurn) {
                    document.getElementById('bid-controls').classList.remove('hidden');
                    document.getElementById('bid-waiting-msg').classList.add('hidden');
                    
                    if (window.localState.lastBidSeen !== currentBid) {
                        let nextMin = currentBid + 1;
                        if(currentBid === 0) nextMin = 1;
                        document.getElementById('player-bid-val').innerText = nextMin;
                        window.localState.lastBidSeen = currentBid;
                    }
                    
                } else {
                    document.getElementById('bid-controls').classList.add('hidden');
                    document.getElementById('bid-waiting-msg').classList.remove('hidden');
                }
            } else {
                bidUI.classList.add('hidden');
                bidUI.classList.remove('flex');
            }

            // Battle UI
            const battleUI = document.getElementById('battle-ui');
            const waitBanner = document.getElementById('wait-banner');
            const isMyBattleTurn = (window.gameState.phase === 'BATTLE' && window.gameState.battle.activePlayer === window.myPlayerIndex);

            if (window.gameState.phase === 'BATTLE') {
                if (isMyBattleTurn) {
                    battleUI.classList.remove('hidden');
                    waitBanner.classList.add('hidden');
                } else {
                    battleUI.classList.add('hidden');
                    waitBanner.classList.remove('hidden');
                }
            } else {
                battleUI.classList.add('hidden');
                waitBanner.classList.add('hidden');
            }

            // Hands
            const h1 = document.getElementById('p1-hand');
            h1.innerHTML = '';
            me.hand.forEach((c, i) => {
                let clickable = isMyBattleTurn && me.mana >= c.cost;
                let style = clickable ? '' : 'filter: grayscale(1) opacity(0.5); cursor: not-allowed;';
                let onclick = clickable ? `onclick="playCard(${i})"` : '';
                h1.innerHTML += createCardHTML(c, style, onclick);
            });

            const h2 = document.getElementById('p2-hand');
            h2.innerHTML = '';
            opp.hand.forEach(() => {
                h2.innerHTML += `<div class="w-12 h-16 bg-gray-800 border border-gray-600 rounded"></div>`;
            });

            checkWinnerRender(me, opp);
        }

        function checkWinnerRender(me, opp) {
            const overlay = document.getElementById('game-over-overlay');
            const p1 = window.gameState.players[0];
            const p2 = window.gameState.players[1];
            
            let winnerIdx = null;
            let reason = "";

            if (window.gameState.winner !== null && window.gameState.winner !== undefined) {
                winnerIdx = window.gameState.winner;
                reason = window.gameState.winReason || "ÁâπÊÆäÂãùÂà©";
            }
            else if (p1.life <= 0 || p2.life <= 0) {
                reason = "„É©„Ç§„ÉïÊ∂àÊªÖ";
                if (p1.life <= 0 && p2.life <= 0) {
                    winnerIdx = -1; // Draw
                } else if (p1.life <= 0) {
                    winnerIdx = 1;
                } else {
                    winnerIdx = 0;
                }
            }

            if (winnerIdx !== null) {
                overlay.classList.remove('hidden');
                overlay.classList.add('active');
                
                let winnerText = "";
                
                if (winnerIdx === -1) winnerText = "Âºï„ÅçÂàÜ„Åë";
                else winnerText = `„Éó„É¨„Ç§„É§„Éº ${winnerIdx + 1} „ÅÆÂãùÂà©ÔºÅ`;

                document.getElementById('winner-text').innerText = winnerText;
                document.getElementById('win-reason').innerText = reason;
            }
        }

        function renderMana(id, val, max) {
            let h = '';
            for(let i=0; i<max; i++) {
                let active = i < val ? 'active' : '';
                h += `<div class="mana-pip ${active}"></div>`;
            }
            document.getElementById(id).innerHTML = h;
        }

        function createCardHTML(c, extraClass='', onclick='') {
            let color = 'gray';
            if(c.type==='A') color='red'; if(c.type==='B') color='blue'; if(c.type==='C') color='purple';
            return `
            <div class="card card-type-${c.type} ${extraClass}" ${onclick}>
                <div class="card-cost">${c.cost}</div>
                <div class="card-title text-${color}-400">${c.name}</div>
                <div class="card-art">${getIcon(c)}</div>
                <div class="card-desc">${c.text}</div>
            </div>`;
        }
        function getIcon(c) {
            if(c.effect==='win') return 'üëë';
            if(c.type==='A') return '‚öîÔ∏è';
            if(c.type==='B') return 'üõ°Ô∏è';
            return 'üîÆ';
        }

        function showCutIn(card, playerName) {
            const overlay = document.getElementById('cut-in-overlay');
            const container = document.getElementById('cut-in-card-container');
            const nameEl = document.getElementById('cut-in-player-name');
            
            nameEl.innerText = `${playerName} „ÅÆ‰ΩøÁî®`;
            container.innerHTML = createCardHTML(card, 'transform scale-150 shadow-2xl');
            
            overlay.classList.remove('hidden');
            void overlay.offsetWidth; 
            overlay.classList.add('active');
            
            setTimeout(() => {
                overlay.classList.remove('active');
                setTimeout(() => overlay.classList.add('hidden'), 300);
            }, 3000); // 3ÁßíÈñìË°®Á§∫
        }

        // Particle BG
        const ctx = document.getElementById('bg-canvas').getContext('2d');
        let ps = Array(50).fill().map(() => ({x:Math.random()*innerWidth, y:Math.random()*innerHeight, s:Math.random()*2, dx:(Math.random()-.5)*.5, dy:-Math.random()*.5}));
        function loop() {
            ctx.clearRect(0,0,innerWidth,innerHeight);
            ctx.fillStyle='#d4af37';
            ps.forEach(p=>{
                p.x+=p.dx; p.y+=p.dy; if(p.y<0) p.y=innerHeight;
                ctx.beginPath(); ctx.arc(p.x,p.y,p.s,0,7); ctx.fill();
            });
            requestAnimationFrame(loop);
        }
        document.getElementById('bg-canvas').width=innerWidth; document.getElementById('bg-canvas').height=innerHeight;
        loop();

    </script>
</body>
</html>
