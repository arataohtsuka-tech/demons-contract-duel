<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Demon's Contract Duel: Online</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Cinzel:wght@400;700&family=Noto+Serif+JP:wght@400;700&display=swap" rel="stylesheet">
    
    <!-- å¤–éƒ¨è¨­å®šãƒ•ã‚¡ã‚¤ãƒ«èª­ã¿è¾¼ã¿ï¼ˆå­˜åœ¨ã™ã‚‹å ´åˆï¼‰ -->
    <script src="config.js" onerror="console.log('Local config.js not found, using manual/env config.')"></script>

    <!-- Firebase SDKs -->
    <script type="module">
        import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
        import { getAuth, signInAnonymously, onAuthStateChanged, signInWithCustomToken } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
        import { getFirestore, collection, doc, setDoc, getDoc, updateDoc, onSnapshot } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";

        window.firebaseApp = null;
        window.db = null;
        window.auth = null;
        window.myPlayerIndex = null;
        window.roomId = null;
        window.unsubscribeRoom = null;
        window.user = null;
        window.localState = { 
            lastTargetIdx: -1, 
            pendingCardIdx: null,
            lastBidSeen: -1,
            lastPlayTimestamp: 0,
            battleActionTaken: false 
        };

        const COLLECTION_NAME = 'demons_contract_rooms_v3'; 
        const appId = typeof __app_id !== 'undefined' ? __app_id : 'default-app-id';

        // â–¼â–¼â–¼â–¼â–¼â–¼â–¼â–¼â–¼â–¼â–¼â–¼â–¼â–¼â–¼â–¼â–¼â–¼â–¼â–¼â–¼â–¼â–¼â–¼â–¼â–¼â–¼â–¼â–¼â–¼â–¼â–¼â–¼â–¼â–¼â–¼â–¼â–¼â–¼â–¼â–¼â–¼â–¼â–¼â–¼â–¼â–¼â–¼â–¼â–¼â–¼â–¼â–¼â–¼â–¼â–¼â–¼â–¼â–¼â–¼â–¼â–¼â–¼â–¼
        const manualConfig = null;
        // â–²â–²â–²â–²â–²â–²â–²â–²â–²â–²â–²â–²â–²â–²â–²â–²â–²â–²â–²â–²â–²â–²â–²â–²â–²â–²â–²â–²â–²â–²â–²â–²â–²â–²â–²â–²â–²â–²â–²â–²â–²â–²â–²â–²â–²â–²â–²â–²â–²â–²â–²â–²â–²â–²â–²â–²â–²â–²â–²â–²â–²â–²â–²â–²

        async function initFirebase() {
            const statusEl = document.getElementById('lobby-status');
            try {
                let firebaseConfig;
                if (typeof window.FIREBASE_CONFIG !== 'undefined') {
                    firebaseConfig = window.FIREBASE_CONFIG;
                } else if (manualConfig) {
                    firebaseConfig = manualConfig;
                } else if (typeof __firebase_config !== 'undefined') {
                    firebaseConfig = JSON.parse(__firebase_config);
                } else {
                    throw new Error("è¨­å®šæœªå®Œäº†: config.jsã‚’ä½œæˆã™ã‚‹ã‹ã‚³ãƒ¼ãƒ‰å†…ã®manualConfigã‚’æ›¸ãæ›ãˆã¦ãã ã•ã„ã€‚");
                }

                statusEl.innerText = "æ¥ç¶šä¸­...";
                window.firebaseApp = initializeApp(firebaseConfig);
                window.auth = getAuth(window.firebaseApp);
                window.db = getFirestore(window.firebaseApp);

                if (typeof __initial_auth_token !== 'undefined' && __initial_auth_token) {
                    await signInWithCustomToken(window.auth, __initial_auth_token);
                } else {
                    await signInAnonymously(window.auth);
                }

                onAuthStateChanged(window.auth, (u) => {
                    if (u) {
                        window.user = u;
                        console.log("Logged in:", u.uid);
                        statusEl.innerText = "æº–å‚™å®Œäº†";
                        statusEl.classList.add('text-green-500');
                        document.getElementById('create-room-btn').disabled = false;
                        document.getElementById('join-room-btn').disabled = false;
                    }
                });

            } catch (e) {
                console.error("Firebase Init Error", e);
                statusEl.innerText = "ã‚¨ãƒ©ãƒ¼: " + e.message;
            }
        }

        // --- Room Logic ---
        window.createRoom = async function() {
            if (!window.user) return;
            const btn = document.getElementById('create-room-btn');
            btn.disabled = true; btn.innerText = "ä½œæˆä¸­...";

            try {
                const roomCode = Math.random().toString(36).substring(2, 8).toUpperCase();
                window.roomId = roomCode;
                window.myPlayerIndex = 0; // Host is P1

                initGameState(); 
                
                const roomRef = doc(window.db, 'artifacts', appId, 'public', 'data', COLLECTION_NAME, roomCode);
                await setDoc(roomRef, {
                    gameState: window.gameState,
                    players: [{uid: window.user.uid, name: "ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ 1"}],
                    createdAt: Date.now(),
                    status: 'WAITING'
                });

                setupRoomListener(roomCode);
                document.getElementById('lobby-screen').classList.add('hidden');
                
                const waitingScreen = document.getElementById('waiting-screen');
                waitingScreen.classList.remove('hidden');
                void waitingScreen.offsetWidth; 
                waitingScreen.classList.add('active'); 
                
                const codeInput = document.getElementById('room-code-display');
                if(codeInput) codeInput.value = roomCode;

            } catch (e) {
                alert("ä½œæˆã‚¨ãƒ©ãƒ¼: " + e.message);
                btn.disabled = false; btn.innerText = "ãƒ«ãƒ¼ãƒ ä½œæˆ";
            }
        }

        window.joinRoom = async function() {
            if (!window.user) return;
            const btn = document.getElementById('join-room-btn');
            btn.disabled = true; btn.innerText = "å‚åŠ ä¸­...";

            try {
                const codeInput = document.getElementById('room-code-input').value.toUpperCase();
                if (!codeInput) throw new Error("ãƒ«ãƒ¼ãƒ ã‚³ãƒ¼ãƒ‰ã‚’å…¥åŠ›ã—ã¦ãã ã•ã„");

                const roomRef = doc(window.db, 'artifacts', appId, 'public', 'data', COLLECTION_NAME, codeInput);
                const snap = await getDoc(roomRef);

                if (!snap.exists()) throw new Error("ãƒ«ãƒ¼ãƒ ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“");
                const data = snap.data();
                if (data.status !== 'WAITING') throw new Error("ãƒ«ãƒ¼ãƒ ã¯æº€å“¡ã‹å¯¾æˆ¦ä¸­ã§ã™");

                window.roomId = codeInput;
                window.myPlayerIndex = 1; // Guest is P2
                
                let updatedPlayers = [...data.players, {uid: window.user.uid, name: "ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ 2"}];
                
                await updateDoc(roomRef, {
                    players: updatedPlayers,
                    status: 'PLAYING'
                });

                setupRoomListener(codeInput);
                document.getElementById('lobby-screen').classList.add('hidden');

            } catch (e) {
                alert("å‚åŠ ã‚¨ãƒ©ãƒ¼: " + e.message);
                btn.disabled = false; btn.innerText = "ãƒ«ãƒ¼ãƒ å‚åŠ ";
            }
        }
        
        window.copyRoomCode = function() {
            const codeInput = document.getElementById('room-code-display');
            if(!codeInput) return;
            codeInput.select();
            codeInput.setSelectionRange(0, 99999);
            try {
                navigator.clipboard.writeText(codeInput.value);
            } catch(err) {
                alert("Code: " + codeInput.value);
            }
        }

        function setupRoomListener(code) {
            const roomRef = doc(window.db, 'artifacts', appId, 'public', 'data', COLLECTION_NAME, code);
            window.unsubscribeRoom = onSnapshot(roomRef, (doc) => {
                if (doc.exists()) {
                    const data = doc.data();
                    if (data.gameState) {
                        // Detect turn change to reset local action state
                        if (window.gameState && window.gameState.battle.activePlayer !== data.gameState.battle.activePlayer) {
                            window.localState.battleActionTaken = false;
                        }
                        window.gameState = data.gameState;
                    }
                    if (data.status === 'PLAYING') {
                         const waiting = document.getElementById('waiting-screen');
                         if(!waiting.classList.contains('hidden')) {
                             waiting.classList.remove('active');
                             setTimeout(() => waiting.classList.add('hidden'), 500); 
                         }
                         render();
                    }
                }
            });
        }

        window.pushState = async function() {
            if (!window.roomId || !window.db) return;
            try {
                const roomRef = doc(window.db, 'artifacts', appId, 'public', 'data', COLLECTION_NAME, window.roomId);
                await updateDoc(roomRef, { gameState: window.gameState });
            } catch (e) { console.error("Sync Error:", e); }
        }

        // --- View Logic ---
        window.viewDiscard = function(playerIdx) {
            if (!window.gameState) return;
            const targetPlayer = window.gameState.players[playerIdx];
            const viewer = document.getElementById('discard-viewer');
            const container = document.getElementById('discard-cards-container');
            const title = document.getElementById('discard-title');
            
            let playerName = (playerIdx === window.myPlayerIndex) ? "ã‚ãªãŸ" : "ç›¸æ‰‹";
            title.innerText = `${playerName} ã®æ¨ã¦æœ­`;
            
            container.innerHTML = '';
            if (targetPlayer.discard.length === 0) {
                container.innerHTML = '<div class="text-gray-500 w-full text-center py-10">ãªã—</div>';
            } else {
                targetPlayer.discard.forEach(card => {
                    container.innerHTML += createCardHTML(card, 'transform scale-90');
                });
            }
            
            viewer.classList.remove('hidden');
            viewer.classList.add('active');
        }

        window.closeDiscard = function() {
            const viewer = document.getElementById('discard-viewer');
            viewer.classList.remove('active');
            setTimeout(() => viewer.classList.add('hidden'), 200);
        }

        window.toggleMenu = function() {
            const menu = document.getElementById('game-menu');
            if (menu.classList.contains('hidden')) {
                menu.classList.remove('hidden');
                void menu.offsetWidth; // Force Reflow
                menu.classList.add('active');
            } else {
                menu.classList.remove('active');
                setTimeout(() => menu.classList.add('hidden'), 300);
            }
        }

        window.showCardList = function() {
            const viewer = document.getElementById('card-list-viewer');
            const container = document.getElementById('all-cards-container');
            container.innerHTML = '';
            
            const sortedCards = [...CARD_DB].sort((a, b) => a.cost - b.cost);
            sortedCards.forEach(card => {
                container.innerHTML += createCardHTML(card, 'transform scale-90');
            });
            
            viewer.classList.remove('hidden');
            void viewer.offsetWidth;
            viewer.classList.add('active');
            
            document.getElementById('game-menu').classList.remove('active');
            document.getElementById('game-menu').classList.add('hidden');
        }

        window.closeCardList = function() {
            const viewer = document.getElementById('card-list-viewer');
            viewer.classList.remove('active');
            setTimeout(() => viewer.classList.add('hidden'), 200);
        }

        window.surrenderGame = function() {
            if(!window.gameState || window.myPlayerIndex === null) return;
            if(!confirm("æœ¬å½“ã«é™å‚ã—ã¾ã™ã‹ï¼Ÿ\nã“ã®æ“ä½œã¯å–ã‚Šæ¶ˆã›ã¾ã›ã‚“ã€‚")) return;
            
            const oppIdx = window.myPlayerIndex === 0 ? 1 : 0;
            const pName = window.gameState.players[window.myPlayerIndex].name;
            window.gameState.winner = oppIdx;
            window.gameState.winReason = "é™å‚";
            addLog(`${pName} ãŒé™å‚ã—ã¾ã—ãŸ`);
            window.pushState();
            window.toggleMenu();
        }

        window.showCardSelector = function(cards, callback) {
            const selector = document.getElementById('card-selector');
            const container = document.getElementById('selector-cards-container');
            container.innerHTML = '';
            
            if(cards.length === 0) {
                alert("å¯¾è±¡ãŒã‚ã‚Šã¾ã›ã‚“ã€‚");
                if(callback) callback(null);
                return;
            }

            cards.forEach((card, originalIndex) => {
                let wrapper = document.createElement('div');
                wrapper.innerHTML = createCardHTML(card, 'cursor-pointer hover:border-yellow-500 transform hover:scale-105 transition-all');
                wrapper.onclick = () => {
                    selector.classList.remove('active');
                    setTimeout(() => selector.classList.add('hidden'), 200);
                    callback(originalIndex);
                };
                container.appendChild(wrapper);
            });

            selector.classList.remove('hidden');
            void selector.offsetWidth;
            selector.classList.add('active');
        }

        window.closeSelector = function() {
            const selector = document.getElementById('card-selector');
            selector.classList.remove('active');
            setTimeout(() => selector.classList.add('hidden'), 200);
        }

        // --- Log (Japanese) ---
        function addLog(msg) {
            if (!window.gameState.logs) window.gameState.logs = [];
            const timestamp = new Date().toLocaleTimeString('ja-JP', { hour: '2-digit', minute: '2-digit', second: '2-digit' });
            window.gameState.logs.push(`[${timestamp}] ${msg}`);
            if (window.gameState.logs.length > 50) window.gameState.logs.shift();
        }

        initFirebase();
    </script>
    
    <style>
        :root {
            --bg-color: #0f0f13;
            --card-bg: #1a1a20;
            --text-color: #e0e0e0;
            --accent-gold: #d4af37;
            --accent-red: #8a0303;
            --accent-blue: #1e3a5f;
            --accent-purple: #4a1e5f;
            --mana-blue: #00bfff;
        }

        body {
            background-color: var(--bg-color);
            color: var(--text-color);
            font-family: 'Noto Serif JP', serif;
            overflow-x: hidden;
            user-select: none;
        }

        h1, h2, h3, .cinzel { font-family: 'Cinzel', serif; }

        #bg-canvas { position: fixed; top: 0; left: 0; width: 100%; height: 100%; z-index: -1; opacity: 0.3; }

        /* Card */
        .card {
            width: 140px; height: 210px;
            background: var(--card-bg);
            border: 2px solid #333; border-radius: 8px;
            position: relative;
            transition: all 0.2s; cursor: pointer;
            overflow: hidden;
            display: flex; flex-direction: column; justify-content: space-between; padding: 6px;
            box-shadow: 0 4px 6px rgba(0,0,0,0.5);
        }
        .card:hover { transform: translateY(-10px) scale(1.05); z-index: 10; border-color: var(--accent-gold); }
        .card.disabled { opacity: 0.4; cursor: not-allowed; filter: grayscale(0.8); }

        .card-type-A { border-color: var(--accent-red); }
        .card-type-B { border-color: var(--accent-blue); }
        .card-type-C { border-color: var(--accent-purple); }
        .card-type-S { border-color: #555; }

        .card-cost {
            position: absolute; top: 4px; right: 4px;
            background: var(--mana-blue); color: #000;
            border-radius: 50%; width: 24px; height: 24px;
            display: flex; align-items: center; justify-content: center;
            font-weight: bold; font-size: 0.8rem; box-shadow: 0 0 5px var(--mana-blue);
        }

        .card-title { font-size: 0.85rem; font-weight: bold; text-align: center; margin-top: 14px; line-height: 1.1; }
        .card-art { flex-grow: 1; display: flex; align-items: center; justify-content: center; font-size: 1.8rem; }
        .card-desc { 
            font-size: 0.7rem; text-align: center; color: #ccc; 
            line-height: 1.3; min-height: 60px; padding: 4px;
            background: rgba(0,0,0,0.3); border-radius: 4px;
            display: flex; align-items: center; justify-content: center;
        }

        /* UI */
        .btn-gothic {
            background: linear-gradient(to bottom, #2a2a35, #1a1a20);
            border: 1px solid var(--accent-gold); color: var(--accent-gold);
            padding: 8px 16px; font-family: 'Cinzel', serif; text-transform: uppercase;
            cursor: pointer; transition: 0.2s;
        }
        .btn-gothic:hover:not(:disabled) { background: var(--accent-gold); color: #000; }
        .btn-gothic:disabled { opacity: 0.5; cursor: not-allowed; border-color: #555; color: #555; }

        .overlay {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.95); z-index: 50;
            display: flex; flex-direction: column; justify-content: center; align-items: center;
            transition: opacity 0.3s; opacity: 0; pointer-events: none;
        }
        .overlay.active { opacity: 1; pointer-events: all; }
        .hidden { display: none !important; }

        .mana-container { display: flex; gap: 2px; margin-top: 4px; justify-content: center; }
        .mana-pip { width: 12px; height: 12px; border-radius: 50%; background: #333; border: 1px solid #555; }
        .mana-pip.active { background: var(--mana-blue); border-color: #fff; box-shadow: 0 0 5px var(--mana-blue); }

        .damage-popup {
            position: absolute; color: #ff0000; font-weight: bold; font-size: 2rem;
            text-shadow: 2px 2px 0 #000; pointer-events: none; z-index: 100;
            animation: floatUp 1s ease-out forwards;
        }
        @keyframes floatUp { 0% { opacity: 1; transform: translateY(0); } 100% { opacity: 0; transform: translateY(-50px); } }
        
        .discard-grid, .selector-grid {
            display: grid; grid-template-columns: repeat(auto-fill, minmax(130px, 1fr));
            gap: 1rem; width: 80%; max-width: 800px; max-height: 70vh; overflow-y: auto; padding: 1rem;
        }

        /* Log Window - Moved to Right Top */
        #log-window {
            position: absolute; top: 70px; right: 10px; width: 220px; height: 180px;
            background: rgba(0, 0, 0, 0.7); border: 1px solid #555; border-radius: 4px;
            font-size: 0.7rem; color: #ccc; z-index: 40; pointer-events: auto;
            display: flex; flex-direction: column;
        }
        #log-header { background: #333; padding: 4px 8px; font-weight: bold; cursor: move; }
        #log-content { flex-grow: 1; overflow-y: auto; padding: 8px; display: flex; flex-direction: column-reverse; }
        .log-entry { margin-bottom: 4px; border-bottom: 1px solid #222; padding-bottom: 2px; }
        
        /* Rules Viewer */
        .rules-content {
            background: rgba(20, 20, 20, 0.95);
            border: 2px solid var(--accent-gold);
            border-radius: 8px;
            padding: 2rem;
            max-width: 600px;
            width: 90%;
            max-height: 80vh;
            overflow-y: auto;
            color: #ddd;
            text-align: left;
        }
        .rules-content h3 { color: var(--accent-gold); font-family: 'Cinzel', serif; margin-top: 1.5rem; margin-bottom: 0.5rem; border-bottom: 1px solid #555; }
        .rules-content ul { list-style-type: disc; padding-left: 1.5rem; margin-bottom: 1rem; }
        .rules-content p { margin-bottom: 1rem; line-height: 1.6; }
    </style>
</head>
<body class="h-screen flex flex-col">
    <canvas id="bg-canvas"></canvas>

    <!-- Lobby -->
    <div id="lobby-screen" class="overlay active" style="z-index: 100;">
        <div class="bg-gray-900 border border-yellow-600 p-8 rounded text-center w-80">
            <h1 class="text-2xl text-yellow-500 mb-4 cinzel">Demon's Contract</h1>
            <p id="lobby-status" class="text-xs text-gray-500 mb-4">Initializing...</p>
            <button id="create-room-btn" onclick="createRoom()" disabled class="btn-gothic w-full mb-4">ãƒ«ãƒ¼ãƒ ä½œæˆ</button>
            <input type="text" id="room-code-input" placeholder="ãƒ«ãƒ¼ãƒ ã‚³ãƒ¼ãƒ‰" class="bg-black border border-gray-600 text-white p-2 w-full mb-2 text-center">
            <button id="join-room-btn" onclick="joinRoom()" disabled class="btn-gothic w-full">ãƒ«ãƒ¼ãƒ å‚åŠ </button>
        </div>
    </div>

    <!-- Waiting -->
    <div id="waiting-screen" class="overlay hidden" style="z-index: 110;">
        <h2 class="text-2xl cinzel text-white mb-4">å¾…æ©Ÿä¸­...</h2>
        <div class="flex gap-2 mb-4 items-center">
            <input type="text" id="room-code-display" readonly class="text-4xl text-yellow-500 bg-black border border-gray-600 p-4 rounded text-center w-64 font-bold tracking-widest">
            <button onclick="copyRoomCode()" class="btn-gothic h-full text-2xl">ğŸ“‹</button>
        </div>
        <p class="text-gray-500 text-xs">å¯¾æˆ¦ç›¸æ‰‹ã‚’å¾…ã£ã¦ã„ã¾ã™...</p>
    </div>

    <!-- Game Menu Overlay -->
    <div id="game-menu" class="overlay hidden" style="z-index: 200;">
        <div class="bg-gray-900 border border-yellow-600 p-8 rounded text-center w-80 flex flex-col gap-4">
            <h2 class="text-2xl text-yellow-500 cinzel">ãƒ¡ãƒ‹ãƒ¥ãƒ¼</h2>
            <button onclick="showCardList()" class="btn-gothic w-full">ğŸ“– ã‚«ãƒ¼ãƒ‰ä¸€è¦§</button>
            <button onclick="showRules()" class="btn-gothic w-full">ğŸ“œ ãƒ«ãƒ¼ãƒ«æ¦‚è¦</button>
            <button onclick="surrenderGame()" class="btn-gothic w-full border-red-500 text-red-500 hover:bg-red-900/30">ğŸ³ï¸ é™å‚</button>
            <div class="h-px bg-gray-700 my-2"></div>
            <button onclick="toggleMenu()" class="btn-gothic w-full border-gray-500 text-gray-400">é–‰ã˜ã‚‹</button>
        </div>
    </div>

    <!-- Rules Viewer -->
    <div id="rules-viewer" class="overlay hidden" style="z-index: 210;">
        <div class="rules-content">
            <h2 class="text-3xl text-center text-yellow-500 mb-4 cinzel">GAME RULES</h2>
            
            <h3>å‹åˆ©æ¡ä»¶</h3>
            <ul>
                <li>ç›¸æ‰‹ã®ãƒ©ã‚¤ãƒ•ã‚’0ã«ã™ã‚‹ã€‚</li>
                <li>ã€Œå¤©ä½¿ã®å¯µæ„›ã€ã‚«ãƒ¼ãƒ‰ã‚’ä½¿ç”¨ã™ã‚‹ã€‚</li>
                <li>10ãƒ©ã‚¦ãƒ³ãƒ‰çµ‚äº†æ™‚ã€ãƒ©ã‚¤ãƒ•ãŒå¤šã„æ–¹ã®å‹åˆ©ã€‚</li>
            </ul>

            <h3>ã‚²ãƒ¼ãƒ ã®æµã‚Œ</h3>
            <p>1ãƒ©ã‚¦ãƒ³ãƒ‰ã¯ã€Œãƒ‰ãƒ©ãƒ•ãƒˆãƒ•ã‚§ã‚¤ã‚ºï¼ˆç«¶ã‚Šï¼‰ã€ã¨ã€Œãƒãƒˆãƒ«ãƒ•ã‚§ã‚¤ã‚ºã€ã§æ§‹æˆã•ã‚Œã¾ã™ã€‚</p>
            
            <h3>1. ãƒ‰ãƒ©ãƒ•ãƒˆãƒ•ã‚§ã‚¤ã‚º</h3>
            <p>ãƒ©ã‚¤ãƒ•ã‚’æ”¯æ‰•ã£ã¦ã‚«ãƒ¼ãƒ‰ã‚’ç²å¾—ã—ã¾ã™ã€‚ç²å¾—ã—ãŸã‚«ãƒ¼ãƒ‰ã¯ã€Œæ¨ã¦æœ­ã€ã«è¡Œãã¾ã™ï¼ˆå³åº§ã«ã¯ä½¿ãˆã¾ã›ã‚“ï¼‰ã€‚</p>
            <ul>
                <li>å¸‚å ´ã®3æšã®ã‚«ãƒ¼ãƒ‰ã«å¯¾ã—ã€é †ç•ªã«å…¥æœ­ã‚’è¡Œã„ã¾ã™ã€‚</li>
                <li>1æšç›®ã¯å¸¸ã« <strong>Player 2</strong> ã‹ã‚‰å…¥æœ­é–‹å§‹ã€‚</li>
                <li>2æšç›®ä»¥é™ã¯ã€ç›´å‰ã®ã‚«ãƒ¼ãƒ‰ã‚’ç²å¾—ã—ãªã‹ã£ãŸï¼ˆç«¶ã‚Šè² ã‘ãŸï¼‰ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã‹ã‚‰å…¥æœ­é–‹å§‹ã€‚</li>
                <li>å…¥æœ­é¡ã®ä¸Šé™ã¯ã€Œç¾åœ¨ãƒ©ã‚¤ãƒ• - 1ã€ã§ã™ã€‚</li>
            </ul>

            <h3>2. ãƒãƒˆãƒ«ãƒ•ã‚§ã‚¤ã‚º</h3>
            <p>æ‰‹æœ­ã®ã‚«ãƒ¼ãƒ‰ã‚’ã€ãƒãƒŠã‚’æ¶ˆè²»ã—ã¦ä½¿ç”¨ã—ã¾ã™ã€‚æ¯ãƒ©ã‚¦ãƒ³ãƒ‰ã€æœ€å¤§ãƒãƒŠãŒå¢—ãˆã¾ã™ï¼ˆR1=1ãƒãƒŠ ... R10=10ãƒãƒŠï¼‰ã€‚</p>
            <ul>
                <li>å¸¸ã« <strong>Player 1</strong> ã‹ã‚‰è¡Œå‹•é–‹å§‹ã€‚</li>
                <li>ã‚«ãƒ¼ãƒ‰ã‚’ä½¿ç”¨ã›ãšã€Œãƒ•ã‚§ã‚¤ã‚ºçµ‚äº†ã€ã‚’æŠ¼ã™ã¨ã€æ‰‹ç•ªãŒç›¸æ‰‹ã«ç§»ã‚Šã¾ã™ã€‚</li>
                <li>ãŠäº’ã„ãŒ1å›ãšã¤ãƒ•ã‚§ã‚¤ã‚ºã‚’çµ‚äº†ã™ã‚‹ã¨ã€æ¬¡ã®ãƒ©ã‚¦ãƒ³ãƒ‰ã¸é€²ã¿ã¾ã™ã€‚</li>
            </ul>
        </div>
        <button onclick="closeRules()" class="btn-gothic mt-4 z-50">é–‰ã˜ã‚‹</button>
    </div>

    <!-- Card List Viewer -->
    <div id="card-list-viewer" class="overlay hidden" style="z-index: 210;">
        <h2 class="text-2xl text-yellow-500 mb-4 cinzel">å…¨ã‚«ãƒ¼ãƒ‰ä¸€è¦§</h2>
        <div id="all-cards-container" class="discard-grid"></div>
        <button onclick="closeCardList()" class="btn-gothic mt-4">é–‰ã˜ã‚‹</button>
    </div>

    <!-- Discard Viewer -->
    <div id="discard-viewer" class="overlay hidden" style="z-index: 120;">
        <h2 id="discard-title" class="text-2xl text-yellow-500 mb-4 cinzel">æ¨ã¦æœ­</h2>
        <div id="discard-cards-container" class="discard-grid"></div>
        <button onclick="closeDiscard()" class="btn-gothic mt-4">é–‰ã˜ã‚‹</button>
    </div>

    <!-- Card Selector (Purge) -->
    <div id="card-selector" class="overlay hidden" style="z-index: 130;">
        <h2 class="text-2xl text-yellow-500 mb-4 cinzel">é™¤å¤–ã™ã‚‹ã‚«ãƒ¼ãƒ‰ã‚’é¸æŠ</h2>
        <p class="text-gray-400 mb-4 text-sm">æ¨ã¦æœ­ã‹ã‚‰ã‚²ãƒ¼ãƒ ã‹ã‚‰é™¤å¤–ã™ã‚‹ã‚«ãƒ¼ãƒ‰ã‚’é¸ã‚“ã§ãã ã•ã„ã€‚</p>
        <div id="selector-cards-container" class="selector-grid"></div>
        <button onclick="closeSelector()" class="btn-gothic mt-4 text-gray-500 border-gray-500">ã‚­ãƒ£ãƒ³ã‚»ãƒ«</button>
    </div>

    <!-- Game UI -->
    <header class="h-12 bg-black/80 flex justify-between items-center px-4 border-b border-gray-800">
        <div class="flex items-center gap-4">
            <span id="round-indicator" class="text-yellow-500 cinzel font-bold">ROUND 1</span>
            <span id="phase-display" class="text-xs text-gray-400">PHASE</span>
        </div>
        <div class="flex items-center gap-4">
            <div class="text-xs text-gray-500" id="player-role-display">Observer</div>
            <button onclick="toggleMenu()" class="btn-gothic px-2 py-1 text-xl leading-none">âš™ï¸</button>
        </div>
    </header>

    <main class="flex-grow flex flex-col relative p-2 overflow-hidden">
        
        <!-- Log Window (Position Changed) -->
        <div id="log-window">
            <div id="log-header">ãƒãƒˆãƒ«ãƒ­ã‚°</div>
            <div id="log-content"></div>
        </div>

        <!-- Opponent -->
        <div class="h-1/4 flex justify-between items-start px-4">
            <div class="flex flex-col items-center">
                <div class="text-xs text-gray-500">ãƒ©ã‚¤ãƒ•</div>
                <div id="p2-life" class="text-3xl text-red-500 cinzel">66</div>
                <div id="p2-mana" class="mana-container"></div>
                <div id="p2-shield" class="text-blue-400 text-xs mt-1"></div>
            </div>
            <div class="flex gap-2">
                <div class="w-16 h-24 bg-gray-800 border border-gray-600 rounded flex items-center justify-center text-xs text-gray-500">å±±æœ­ <span id="p2-deck-count" class="ml-1 text-white">0</span></div>
                <div class="w-16 h-24 bg-gray-800 border border-gray-600 rounded flex items-center justify-center text-xs text-gray-500 cursor-pointer hover:border-white transition-colors" onclick="viewDiscard(window.myPlayerIndex === 0 ? 1 : 0)">
                    æ¨ã¦æœ­
                </div>
            </div>
        </div>

        <!-- Center (Market & Bidding) -->
        <div class="flex-grow flex justify-center items-center relative">
            <div id="market-area" class="flex gap-4 z-10 transition-all"></div>

            <!-- Bidding UI -->
            <div id="bidding-ui" class="absolute bg-black/90 border border-yellow-600 p-4 rounded z-20 flex hidden w-[500px]">
                <div class="flex-1 flex flex-col items-center gap-2 pr-4 border-r border-gray-700">
                    <div class="text-yellow-500 cinzel">ç«¶ã‚Šä¸­</div>
                    <div class="flex w-full justify-between items-center text-sm text-gray-300">
                        <span>ç¾åœ¨å€¤: <span id="bid-current-val" class="text-white font-bold text-xl">0</span></span>
                    </div>
                    <div class="text-xs text-red-400 mb-2" id="bid-highest-player">-</div>
                    
                    <div id="bid-controls" class="w-full">
                        <div class="flex justify-center items-center gap-4 my-2">
                            <button onclick="adjustBid(-1)" class="btn-gothic px-2 py-0">-</button>
                            <span id="player-bid-val" class="text-2xl font-bold text-white">1</span>
                            <button onclick="adjustBid(1)" class="btn-gothic px-2 py-0">+</button>
                        </div>
                        <div class="flex gap-2 justify-center">
                            <button onclick="submitBid()" class="btn-gothic bg-red-900/50">å®£è¨€</button>
                            <button onclick="passBid()" class="btn-gothic border-gray-600 text-gray-400">ãƒ‘ã‚¹</button>
                        </div>
                        <div class="text-xs text-gray-500 mt-2 text-center">ä¸Šé™: ãƒ©ã‚¤ãƒ• - 1</div>
                    </div>
                    <div id="bid-waiting-msg" class="text-xs text-yellow-500 animate-pulse hidden">ç›¸æ‰‹ã®æ“ä½œå¾…ã¡...</div>
                </div>

                <div class="flex-1 flex flex-col items-center justify-center pl-4">
                    <div class="text-xs text-gray-400 mb-1">å¯¾è±¡ã‚«ãƒ¼ãƒ‰</div>
                    <div id="bid-card-preview" class="scale-90 origin-top"></div>
                </div>
            </div>

            <!-- Battle Turn Indicator -->
            <div id="battle-ui" class="absolute bottom-4 z-20 hidden">
                <button id="end-turn-btn" onclick="endBattlePhase()" class="btn-gothic bg-blue-900/50 text-white px-8 py-2">ãƒ•ã‚§ã‚¤ã‚ºçµ‚äº†</button>
            </div>
            <div id="wait-banner" class="absolute bottom-12 bg-black/80 px-4 py-1 rounded text-gray-400 text-sm hidden">ç›¸æ‰‹ã®ã‚¿ãƒ¼ãƒ³</div>
        </div>

        <!-- Player -->
        <div class="h-1/3 flex justify-between items-end px-4 pb-2 bg-gradient-to-t from-black/80 to-transparent">
            <div class="flex flex-col items-center">
                <div class="text-xs text-gray-500">ãƒ©ã‚¤ãƒ•</div>
                <div id="p1-life" class="text-3xl text-red-500 cinzel">66</div>
                <div id="p1-mana" class="mana-container"></div>
                <div id="p1-shield" class="text-blue-400 text-xs mt-1"></div>
            </div>
            
            <div class="flex gap-4 items-end">
                <div class="flex flex-col items-center">
                    <div id="p1-hand" class="flex gap-2 mb-2 justify-center"></div>
                    <div class="text-xs text-gray-500">æ‰‹æœ­</div>
                </div>
                <div class="flex gap-2">
                    <div class="w-16 h-24 bg-gray-800 border border-gray-600 rounded flex items-center justify-center text-xs text-gray-500 relative">å±±æœ­ <span id="p1-deck-count" class="absolute -top-2 -right-2 bg-blue-600 text-white rounded-full w-5 h-5 flex items-center justify-center">0</span></div>
                    <div class="w-16 h-24 bg-gray-800 border border-gray-600 rounded flex items-center justify-center text-xs text-gray-500 cursor-pointer hover:border-white transition-colors" onclick="viewDiscard(window.myPlayerIndex)">
                        æ¨ã¦æœ­
                    </div>
                </div>
            </div>
        </div>
    </main>

    <!-- Game Over -->
    <div id="game-over-overlay" class="overlay hidden" style="z-index: 200;">
        <h2 id="winner-text" class="text-4xl text-yellow-500 mb-4 cinzel">WINNER</h2>
        <p id="win-reason" class="text-gray-400 mb-8">Reason</p>
        <button onclick="location.reload()" class="btn-gothic">ãƒ­ãƒ“ãƒ¼ã«æˆ»ã‚‹</button>
    </div>

    <script>
        // --- CONSTANTS & CARD DB (Updated to Specs) ---
        const CONSTANTS = { MAX_ROUNDS: 10, INITIAL_LIFE: 66, INITIAL_HAND: 3 };

        const CARD_DB = [
            // Starter
            { id: 'S-1', type: 'S', name: 'ç”Ÿè´„ã®è¡€', cost: 0, text: 'ç›¸æ‰‹ã«1ãƒ€ãƒ¡ãƒ¼ã‚¸ã‚’ä¸ãˆã‚‹ã€‚', power: 1, selfDmg: 0, effect: 'dmg' },
            { id: 'S-2', type: 'S', name: 'å¾®å¼±ãªé­”åŠ›', cost: 1, text: 'ã‚«ãƒ¼ãƒ‰ã‚’1æšå¼•ãã€‚è‡ªèº«ã®ãƒ©ã‚¤ãƒ•ã‚’1å¤±ã†ã€‚', power: 0, selfDmg: 1, effect: 'draw' },
            // A - Attack
            { id: 'A-1', type: 'A', name: 'å„€å¼ã®çŸ­å‰£', cost: 0, text: 'ç›¸æ‰‹ã«2ãƒ€ãƒ¡ãƒ¼ã‚¸ã‚’ä¸ãˆã‚‹ã€‚', power: 2, selfDmg: 0, effect: 'dmg' },
            { id: 'A-2', type: 'A', name: 'é­”åŠ›é›†ä¸­', cost: 1, text: 'ã‚«ãƒ¼ãƒ‰ã‚’1æšå¼•ãã€‚ç›¸æ‰‹ã«2ãƒ€ãƒ¡ãƒ¼ã‚¸ã‚’ä¸ãˆã‚‹ã€‚', power: 2, selfDmg: 0, effect: 'dmg_draw' },
            { id: 'A-3', type: 'A', name: 'æµ„åŒ–ã®ç«', cost: 2, text: 'ç›¸æ‰‹ã«3ãƒ€ãƒ¡ãƒ¼ã‚¸ã‚’ä¸ãˆã‚‹ã€‚æ¨ã¦æœ­ã«ã‚ã‚‹Sã‚«ãƒ¼ãƒ‰ã‚’1æšé™¤å¤–ã™ã‚‹ï¼ˆé¸æŠï¼‰ã€‚', power: 3, selfDmg: 0, effect: 'dmg_purge' },
            { id: 'A-4', type: 'A', name: 'å¼·æ¬²ã®å‰£', cost: 3, text: 'ã‚«ãƒ¼ãƒ‰ã‚’1æšå¼•ãã€‚ç›¸æ‰‹ã«5ãƒ€ãƒ¡ãƒ¼ã‚¸ã‚’ä¸ãˆã‚‹ã€‚', power: 5, selfDmg: 0, effect: 'dmg_draw' },
            { id: 'A-5', type: 'A', name: 'é€£é–ã®å‘ªã„', cost: 2, text: 'ç›¸æ‰‹ã«3ãƒ€ãƒ¡ãƒ¼ã‚¸ã‚’ä¸ãˆã‚‹ã€‚ä½¿ç”¨å¾Œã€æ¨ã¦æœ­ã§ã¯ãªãå±±æœ­ã®ä¸‹ã«æˆ»ã‚‹ã€‚', power: 3, selfDmg: 0, effect: 'dmg_recycle' },
            { id: 'A-6', type: 'A', name: 'é­‚ã®å¸å', cost: 4, text: 'ç›¸æ‰‹ã«5ãƒ€ãƒ¡ãƒ¼ã‚¸ã‚’ä¸ãˆã‚‹ã€‚è‡ªèº«ã®ãƒ©ã‚¤ãƒ•ã‚’3å›å¾©ã™ã‚‹ã€‚', power: 5, selfDmg: 0, effect: 'dmg_heal', val: 3 },
            { id: 'A-7', type: 'A', name: 'æ‚ªé­”ã®å¥‘ç´„', cost: 9, text: 'ç›¸æ‰‹ã«20ãƒ€ãƒ¡ãƒ¼ã‚¸ã‚’ä¸ãˆã‚‹ã€‚è‡ªèº«ã®ãƒ©ã‚¤ãƒ•ã‚’20å¤±ã†ã€‚', power: 20, selfDmg: 20, effect: 'dmg' },
            // B - Defense
            { id: 'B-1', type: 'B', name: 'ç¬é–“ä¿®å¾©', cost: 1, text: 'è‡ªèº«ã®ãƒ©ã‚¤ãƒ•ã‚’2å›å¾©ã™ã‚‹ã€‚', power: 0, selfDmg: 0, effect: 'heal', val: 2 },
            { id: 'B-2', type: 'B', name: 'é­‚ã®è§£æ”¾', cost: 2, text: 'è‡ªèº«ã®ãƒ©ã‚¤ãƒ•ã‚’2å›å¾©ã™ã‚‹ã€‚æ‰‹æœ­ã‚’1æšé¸ã³é™¤å¤–ã™ã‚‹ã€‚', power: 0, selfDmg: 0, effect: 'heal_banish', val: 2 },
            { id: 'B-3', type: 'B', name: 'ç™’ã‚„ã—ã®åˆ»å°', cost: 3, text: 'è‡ªèº«ã®ãƒ©ã‚¤ãƒ•ã‚’5å›å¾©ã™ã‚‹ã€‚', power: 0, selfDmg: 0, effect: 'heal', val: 5 },
            { id: 'B-4', type: 'B', name: 'é˜²å¾¡ã®çµç•Œ', cost: 5, text: 'æ¬¡ã«å—ã‘ã‚‹ãƒ€ãƒ¡ãƒ¼ã‚¸ã‚’1å›ã ã‘ç„¡åŠ¹åŒ–ã™ã‚‹ã€‚', power: 0, selfDmg: 0, effect: 'nullify' },
            { id: 'B-5', type: 'B', name: 'åå°„ã®é¡', cost: 7, text: 'æ¬¡ã«å—ã‘ã‚‹ãƒ€ãƒ¡ãƒ¼ã‚¸ã‚’ç„¡åŠ¹åŒ–ã—ã€ãã®ãƒ€ãƒ¡ãƒ¼ã‚¸ã‚’ç›¸æ‰‹ã«ä¸ãˆã‚‹ã€‚', power: 0, selfDmg: 0, effect: 'reflect' },
            // C - Control
            { id: 'C-1', type: 'C', name: 'é­”åŠ›ã®æ¹§å‡º', cost: 0, text: 'ã“ã®ã‚¿ãƒ¼ãƒ³ã®ã¿ãƒãƒŠ+2ã€‚ä½¿ç”¨å¾Œã€ã“ã®ã‚«ãƒ¼ãƒ‰ã¯ã‚²ãƒ¼ãƒ ã‹ã‚‰é™¤å¤–ã•ã‚Œã‚‹ã€‚', power: 0, selfDmg: 0, effect: 'mana_boost', val: 2, banish: true },
            { id: 'C-2', type: 'C', name: 'æœªæ¥ã®è¦–ç·š', cost: 1, text: 'å±±æœ­ã®ä¸Šã‹ã‚‰4æšã‚’è¦‹ã¦ã€å¥½ããªé †ç•ªã§æˆ»ã™ã€‚ï¼ˆæœªå®Ÿè£…ï¼šã‚·ãƒ£ãƒƒãƒ•ãƒ«ï¼‰', power: 0, selfDmg: 0, effect: 'scry' },
            { id: 'C-3', type: 'C', name: 'çŸ¥è­˜ã®è­²æ¸¡', cost: 2, text: 'ã‚«ãƒ¼ãƒ‰ã‚’2æšå¼•ãã€‚', power: 0, selfDmg: 0, effect: 'draw_2' },
            { id: 'C-4', type: 'C', name: 'æ™‚ã®ç ‚', cost: 2, text: 'æ¨ã¦æœ­ã®Sã‚«ãƒ¼ãƒ‰ã‚’1æšé™¤å¤–ã—ãŸå¾Œã€æ¨ã¦æœ­ã‚’å±±æœ­ã«æˆ»ã—ã‚·ãƒ£ãƒƒãƒ•ãƒ«ã™ã‚‹ã€‚1æšå¼•ãã€‚', power: 0, selfDmg: 0, effect: 'reshuffle_draw' },
            { id: 'C-5', type: 'C', name: 'å¤©ä½¿ã®å¯µæ„›', cost: 10, text: 'ã€ç‰¹æ®Šå‹åˆ©ã€‘ã“ã®ã‚²ãƒ¼ãƒ ã«å‹åˆ©ã™ã‚‹ã€‚', power: 0, selfDmg: 0, effect: 'win' }
        ];

        // --- Game State Structure ---
        window.gameState = {
            round: 1,
            phase: 'MARKET', 
            players: [], 
            market: [],
            contractDeck: [],
            bidding: { targetIdx: 0, currentBid: 0, highestBidder: null, turn: 0, passCount: 0, starter: 0 },
            battle: { activePlayer: 0 }, 
            winner: null,
            winReason: null,
            logs: [],
            latestPlay: { cardId: null, player: null, timestamp: 0 }
        };

        // --- Logic ---
        function initGameState() {
            let deck = [];
            CARD_DB.forEach(c => {
                if(c.type !== 'S') {
                    deck.push({...c, uuid: crypto.randomUUID()});
                    deck.push({...c, uuid: crypto.randomUUID()});
                }
            });
            window.gameState.contractDeck = shuffle(deck);

            window.gameState.players = [0, 1].map(id => ({
                id, name: `ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ ${id+1}`,
                life: CONSTANTS.INITIAL_LIFE,
                mana: 1, maxMana: 1,
                deck: [], hand: [], discard: [],
                shield: 0, nullify: false, reflect: false
            }));

            // Initial Decks (Asymmetric)
            window.gameState.players.forEach((p, index) => {
                let starters = [];
                let s1Count = (index === 0) ? 3 : 2; // P1: 3x S-1, P2: 2x S-1
                let s2Count = (index === 0) ? 2 : 1; // P1: 2x S-2, P2: 1x S-2
                
                for(let i=0; i<s1Count; i++) starters.push({...CARD_DB[0], uuid: crypto.randomUUID()});
                for(let i=0; i<s2Count; i++) starters.push({...CARD_DB[1], uuid: crypto.randomUUID()});
                
                p.deck = shuffle(starters);
                drawCards(p, CONSTANTS.INITIAL_HAND);
            });

            window.gameState.winner = null;
            window.gameState.winReason = null;
            window.gameState.logs = [];
            window.gameState.latestPlay = { cardId: null, player: null, timestamp: 0 };

            startRound();
        }

        function startRound() {
            window.gameState.phase = 'MARKET';
            window.gameState.market = [];
            for(let i=0; i<3; i++) {
                if(window.gameState.contractDeck.length > 0) window.gameState.market.push(window.gameState.contractDeck.pop());
            }
            
            let mana = window.gameState.round;
            if(mana > 10) mana = 10;
            window.gameState.players.forEach(p => {
                p.maxMana = mana;
                p.mana = mana;
            });

            addLog(`=== ç¬¬ ${window.gameState.round} ãƒ©ã‚¦ãƒ³ãƒ‰ é–‹å§‹ ===`);

            setTimeout(() => {
                // Draft 1st card always starts with Player 2 (index 1)
                startBidding(0, 1);
            }, 1000);
        }

        function startBidding(cardIdx, starterIdx) {
            if (cardIdx >= window.gameState.market.length) {
                startBattlePhase();
                return;
            }
            window.gameState.phase = 'BIDDING';
            window.gameState.bidding = {
                targetIdx: cardIdx,
                currentBid: 0,
                highestBidder: null,
                turn: starterIdx,
                passCount: 0,
                starter: starterIdx
            };
            const targetName = window.gameState.market[cardIdx]?.name || "Unknown";
            addLog(`${targetName} ã®ç«¶ã‚Šé–‹å§‹ (é–‹å§‹: ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ ${starterIdx + 1})`);
            window.pushState();
        }

        // --- Interaction ---
        function checkMyTurn(context) {
            if (window.myPlayerIndex === null) return false;
            if (context === 'BID') return window.gameState.phase === 'BIDDING' && window.gameState.bidding.turn === window.myPlayerIndex;
            if (context === 'BATTLE') return window.gameState.phase === 'BATTLE' && window.gameState.battle.activePlayer === window.myPlayerIndex;
            return false;
        }

        function adjustBid(delta) {
            if (!checkMyTurn('BID')) return;
            const el = document.getElementById('player-bid-val');
            let val = parseInt(el.innerText) + delta;
            
            let min = window.gameState.bidding.currentBid + 1;
            if (val < min) val = min;
            
            const me = window.gameState.players[window.myPlayerIndex];
            let maxBid = Math.max(1, me.life - 1); 
            if (val > maxBid) val = maxBid;
            
            el.innerText = val;
        }

        function resolveBid(winnerIdx, cost) {
            const winner = window.gameState.players[winnerIdx];
            const card = window.gameState.market[window.gameState.bidding.targetIdx];
            
            winner.life -= cost;
            winner.discard.push(card); 
            
            addLog(`${winner.name} ãŒ ${card.name} ã‚’ãƒ©ã‚¤ãƒ• ${cost} ã§è½æœ­`);

            // è½æœ­ã—ãªã‹ã£ãŸãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ï¼ˆï¼ä»Šå›è² ã‘ãŸå´ï¼‰ãŒæ¬¡ã®é–‹å§‹æ¨©ã‚’æŒã¤
            let nextStarter = (winnerIdx === 0) ? 1 : 0;
            let nextIdx = window.gameState.bidding.targetIdx + 1;
            startBidding(nextIdx, nextStarter);
        }

        function submitBid() {
            if (!checkMyTurn('BID')) return;
            const val = parseInt(document.getElementById('player-bid-val').innerText);
            
            const me = window.gameState.players[window.myPlayerIndex];
            if (val >= me.life) {
                alert("Bid too high! Must have 1 life remaining.");
                return;
            }

            if (window.gameState.bidding.passCount > 0) {
                resolveBid(window.myPlayerIndex, val);
                return;
            }

            window.gameState.bidding.currentBid = val;
            window.gameState.bidding.highestBidder = window.myPlayerIndex;
            window.gameState.bidding.turn = (window.myPlayerIndex === 0) ? 1 : 0;
            window.gameState.bidding.passCount = 0;
            
            addLog(`${me.name} ãŒ ${val} ã‚’å®£è¨€`);
            window.pushState();
        }

        function passBid() {
            if (!checkMyTurn('BID')) return;
            
            const me = window.gameState.players[window.myPlayerIndex];
            addLog(`${me.name} ãŒãƒ‘ã‚¹`);

            if (window.gameState.bidding.highestBidder !== null) {
                resolveBid(window.gameState.bidding.highestBidder, window.gameState.bidding.currentBid);
            } else {
                window.gameState.bidding.passCount = (window.gameState.bidding.passCount || 0) + 1;
                
                if (window.gameState.bidding.passCount >= 2) {
                    addLog("ä¸¡è€…ãƒ‘ã‚¹ã€‚ã‚«ãƒ¼ãƒ‰ã¯ç ´æ£„ã•ã‚Œã¾ã—ãŸ");
                    // ä¸¡è€…ãƒ‘ã‚¹ã®å ´åˆã€ä»Šå›ã®é–‹å§‹ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã®ã€Œç›¸æ‰‹ã€ã‹ã‚‰æ¬¡ã‚’å§‹ã‚ã‚‹
                    let currentStarter = window.gameState.bidding.starter;
                    let nextStarter = (currentStarter === 0) ? 1 : 0;

                    let nextIdx = window.gameState.bidding.targetIdx + 1;
                    startBidding(nextIdx, nextStarter);
                } else {
                    window.gameState.bidding.turn = (window.myPlayerIndex === 0) ? 1 : 0;
                    window.pushState();
                }
            }
        }

        function startBattlePhase() {
            window.gameState.phase = 'BATTLE';
            // ã€ä¿®æ­£ã€‘ãƒãƒˆãƒ«ãƒ•ã‚§ã‚¤ã‚ºã®é–‹å§‹ã¯å¸¸ã« Player 1
            window.gameState.battle.activePlayer = 0;
            addLog("=== ãƒãƒˆãƒ«ãƒ•ã‚§ã‚¤ã‚º é–‹å§‹ ===");
            window.pushState();
        }

        function playCard(cardIdx, purgeTargetIdx = null) {
            if (!checkMyTurn('BATTLE')) return;
            const pIdx = window.myPlayerIndex;
            const player = window.gameState.players[pIdx];
            const card = player.hand[cardIdx];
            const oppIdx = (pIdx === 0) ? 1 : 0;
            const opp = window.gameState.players[oppIdx];

            // B-2 logic: Manual select from hand (excluding self)
            if (card.id === 'B-2' && purgeTargetIdx === null) {
                const handCards = player.hand.map((c, i) => ({...c, originalIdx: i})).filter((c, i) => i !== cardIdx);
                if (handCards.length > 0) {
                    window.localState.pendingCardIdx = cardIdx;
                    showCardSelector(handCards, (selectedIndex) => {
                        if (selectedIndex !== null) {
                            const trueHandIdx = handCards[selectedIndex].originalIdx;
                            playCard(cardIdx, trueHandIdx);
                        }
                    });
                    return; 
                }
            }

            // A-3 logic: Manual select from discard
            if (card.id === 'A-3' && purgeTargetIdx === null) {
                const sCards = player.discard.map((c, i) => ({...c, originalIdx: i})).filter(c => c.type === 'S');
                if (sCards.length > 0) {
                    window.localState.pendingCardIdx = cardIdx;
                    showCardSelector(sCards, (selectedIndex) => {
                        if (selectedIndex !== null) {
                            const trueDiscardIdx = sCards[selectedIndex].originalIdx;
                            playCard(cardIdx, trueDiscardIdx);
                        }
                    });
                    return; 
                }
            }

            if (player.mana < card.cost) {
                alert("Not enough Mana!");
                return;
            }

            addLog(`${player.name} ãŒ ${card.name} ã‚’ä½¿ç”¨`);
            
            player.mana -= card.cost;
            let dmg = card.power;
            
            if (card.selfDmg > 0) player.life -= card.selfDmg;

            if (card.effect === 'win') {
                window.gameState.winner = pIdx;
                window.gameState.winReason = "å¤©ä½¿ã®å¯µæ„›";
            }

            if (card.effect.includes('dmg')) {
                if (opp.reflect) {
                    player.life -= dmg; 
                    opp.reflect = false;
                    dmg = 0;
                    addLog(`ãƒ€ãƒ¡ãƒ¼ã‚¸åå°„ï¼`);
                } else if (opp.nullify) {
                    dmg = 0;
                    opp.nullify = false;
                    addLog(`ãƒ€ãƒ¡ãƒ¼ã‚¸ç„¡åŠ¹åŒ–ï¼`);
                } else {
                    if (opp.shield > 0) {
                        let blocked = Math.min(opp.shield, dmg);
                        opp.shield -= blocked;
                        dmg -= blocked;
                    }
                    if (dmg > 0) opp.life -= dmg;
                }
            }

            if (card.effect.includes('draw')) {
                let n = (card.effect === 'draw_2') ? 2 : 1;
                drawCards(player, n);
            }
            
            if (card.effect.includes('heal')) {
                let heal = card.val || 0;
                player.life += heal;
                
                if (card.id === 'B-2' && purgeTargetIdx !== null) {
                    const targetName = player.hand[purgeTargetIdx].name;
                    player.hand.splice(purgeTargetIdx, 1);
                    addLog(`${targetName} ã‚’æ‰‹æœ­ã‹ã‚‰é™¤å¤–ã—ã¾ã—ãŸ`);
                    if (purgeTargetIdx < cardIdx) {
                        cardIdx--;
                    }
                }
            }

            if (card.effect === 'nullify') player.nullify = true;
            if (card.effect === 'reflect') player.reflect = true;
            if (card.effect === 'mana_boost') player.mana += card.val;
            
            if (card.id === 'A-3' && purgeTargetIdx !== null) {
                player.discard.splice(purgeTargetIdx, 1);
                addLog(`æ¨ã¦æœ­ã‚’é™¤å¤–ã—ã¾ã—ãŸ`);
            }
            
            if (card.effect === 'reshuffle_draw') {
                // C-4: Auto purge 1 S
                const sIndex = player.discard.findIndex(c => c.type === 'S');
                if(sIndex !== -1) player.discard.splice(sIndex, 1);
                
                player.deck = player.deck.concat(player.discard);
                player.discard = [];
                player.deck = shuffle(player.deck);
                drawCards(player, 1);
                addLog(`æ¨ã¦æœ­ã‚’å±±æœ­ã«æˆ»ã—ã¾ã—ãŸ`);
            }

            if (card.effect === 'scry') { }

            player.hand.splice(cardIdx, 1);
            
            if (card.banish) {
                addLog(`${card.name} ã¯é™¤å¤–ã•ã‚Œã¾ã—ãŸ`);
            } else if (card.effect === 'dmg_recycle') {
                player.deck.unshift(card);
            } else {
                player.discard.push(card);
            }

            render(); 
            window.pushState();
        }

        function endBattlePhase() {
            if (!checkMyTurn('BATTLE')) return;
            
            const currentActor = window.gameState.battle.activePlayer;
            const pName = window.gameState.players[window.myPlayerIndex].name;

            addLog(`${pName} ãŒãƒ•ã‚§ã‚¤ã‚ºçµ‚äº†`);

            if (currentActor === 0) {
                window.gameState.battle.activePlayer = 1;
            } else {
                endRound();
                return;
            }
            
            window.pushState();
        }

        function endRound() {
            window.gameState.players.forEach(p => {
                p.discard = p.discard.concat(p.hand);
                p.hand = [];
                p.shield = 0; p.nullify = false; p.reflect = false;
                drawCards(p, CONSTANTS.INITIAL_HAND);
            });
            window.gameState.round++;
            if (window.gameState.round > CONSTANTS.MAX_ROUNDS) {
                let p1 = window.gameState.players[0];
                let p2 = window.gameState.players[1];
                if(p1.life > p2.life) forceEndGame("Player 1", "æ™‚é–“åˆ‡ã‚Œ");
                else forceEndGame("Player 2", "æ™‚é–“åˆ‡ã‚Œ");
                return;
            } else {
                startRound();
            }
        }

        // --- Utils ---
        function addLog(msg) {
            if (!window.gameState.logs) window.gameState.logs = [];
            const ts = new Date().toTimeString().split(' ')[0];
            window.gameState.logs.push(`[${ts}] ${msg}`);
            if (window.gameState.logs.length > 50) window.gameState.logs.shift();
        }

        function drawCards(p, n) {
            for(let i=0; i<n; i++) {
                if (p.deck.length === 0) {
                    if (p.discard.length === 0) break;
                    p.deck = shuffle(p.discard);
                    p.discard = [];
                }
                p.hand.push(p.deck.pop());
            }
        }
        function shuffle(arr) { return arr.sort(() => Math.random() - 0.5); }
        
        function forceEndGame(winner, reason) {
            window.gameState.winReason = reason;
            if(winner === "Player 1") window.gameState.winner = 0;
            else window.gameState.winner = 1;
            startRound(); 
        }

        // --- Render ---
        function render() {
            if (!window.gameState || window.myPlayerIndex === null) return;
            const me = window.gameState.players[window.myPlayerIndex];
            const opp = window.gameState.players[window.myPlayerIndex === 0 ? 1 : 0];

            document.getElementById('player-role-display').innerText = `You: ${me.name}`;
            document.getElementById('round-indicator').innerText = `ROUND ${window.gameState.round}`;
            document.getElementById('phase-display').innerText = window.gameState.phase;

            // Logs
            const logContent = document.getElementById('log-content');
            if (window.gameState.logs) {
                logContent.innerHTML = window.gameState.logs.slice().reverse().map(l => `<div class="log-entry">${l}</div>`).join('');
            }

            // Stats
            document.getElementById('p1-life').innerText = me.life;
            document.getElementById('p2-life').innerText = opp.life;
            renderMana('p1-mana', me.mana, me.maxMana);
            renderMana('p2-mana', opp.mana, opp.maxMana);
            
            document.getElementById('p1-deck-count').innerText = me.deck.length;
            document.getElementById('p2-deck-count').innerText = opp.deck.length;

            // --- Market Render ---
            const mArea = document.getElementById('market-area');
            mArea.innerHTML = '';
            
            if (window.gameState.phase !== 'BATTLE') {
                window.gameState.market.forEach((c, i) => {
                    let isTarget = (window.gameState.phase === 'BIDDING' && window.gameState.bidding.targetIdx === i);
                    let opacity = (window.gameState.phase === 'BIDDING' && !isTarget) ? 'opacity-30' : '';
                    let border = isTarget ? 'border-yellow-500 shadow-lg shadow-yellow-500/50' : '';
                    mArea.innerHTML += createCardHTML(c, `${opacity} ${border}`);
                });
            }

            // Bidding UI
            const bidUI = document.getElementById('bidding-ui');
            const isMyBidTurn = (window.gameState.phase === 'BIDDING' && window.gameState.bidding.turn === window.myPlayerIndex);
            
            if (window.gameState.phase === 'BIDDING') {
                bidUI.classList.remove('hidden');
                bidUI.classList.add('flex');
                
                const targetCard = window.gameState.market[window.gameState.bidding.targetIdx];
                if(targetCard) {
                    document.getElementById('bid-card-preview').innerHTML = createCardHTML(targetCard, '', '');
                }

                const currentBid = window.gameState.bidding.currentBid;
                document.getElementById('bid-current-val').innerText = currentBid;
                let highest = window.gameState.bidding.highestBidder;
                document.getElementById('bid-highest-player').innerText = highest === null ? "None" : (highest === window.myPlayerIndex ? "ã‚ãªãŸ" : "ç›¸æ‰‹");

                if (isMyBidTurn) {
                    document.getElementById('bid-controls').classList.remove('hidden');
                    document.getElementById('bid-waiting-msg').classList.add('hidden');
                    
                    if (window.localState.lastBidSeen !== currentBid) {
                        let nextMin = currentBid + 1;
                        if(currentBid === 0) nextMin = 1;
                        document.getElementById('player-bid-val').innerText = nextMin;
                        window.localState.lastBidSeen = currentBid;
                    }
                    
                } else {
                    document.getElementById('bid-controls').classList.add('hidden');
                    document.getElementById('bid-waiting-msg').classList.remove('hidden');
                }
            } else {
                bidUI.classList.add('hidden');
                bidUI.classList.remove('flex');
            }

            // Battle UI
            const battleUI = document.getElementById('battle-ui');
            const endBtn = document.getElementById('end-turn-btn');
            const waitBanner = document.getElementById('wait-banner');
            const isMyBattleTurn = (window.gameState.phase === 'BATTLE' && window.gameState.battle.activePlayer === window.myPlayerIndex);

            if (window.gameState.phase === 'BATTLE') {
                if (isMyBattleTurn) {
                    battleUI.classList.remove('hidden');
                    waitBanner.classList.add('hidden');
                    endBtn.innerText = "ãƒ•ã‚§ã‚¤ã‚ºçµ‚äº†";
                } else {
                    battleUI.classList.add('hidden');
                    waitBanner.classList.remove('hidden');
                    waitBanner.innerText = "ç›¸æ‰‹ã®ã‚¿ãƒ¼ãƒ³";
                }
            } else {
                battleUI.classList.add('hidden');
                waitBanner.classList.add('hidden');
            }

            // Hands
            const h1 = document.getElementById('p1-hand');
            h1.innerHTML = '';
            me.hand.forEach((c, i) => {
                let clickable = isMyBattleTurn && me.mana >= c.cost;
                let style = clickable ? '' : 'filter: grayscale(1) opacity(0.5); cursor: not-allowed;';
                let onclick = clickable ? `onclick="playCard(${i})"` : '';
                h1.innerHTML += createCardHTML(c, style, onclick);
            });

            const h2 = document.getElementById('p2-hand');
            h2.innerHTML = '';
            opp.hand.forEach(() => {
                h2.innerHTML += `<div class="w-12 h-16 bg-gray-800 border border-gray-600 rounded"></div>`;
            });

            checkWinnerRender(me, opp);
        }

        function checkWinnerRender(me, opp) {
            const overlay = document.getElementById('game-over-overlay');
            const p1 = window.gameState.players[0];
            const p2 = window.gameState.players[1];
            
            let winnerIdx = null;
            let reason = "";

            if (window.gameState.winner !== null && window.gameState.winner !== undefined) {
                winnerIdx = window.gameState.winner;
                reason = window.gameState.winReason || "ç‰¹æ®Šå‹åˆ©";
            }
            else if (p1.life <= 0 || p2.life <= 0) {
                reason = "ãƒ©ã‚¤ãƒ•æ¶ˆæ»…";
                if (p1.life <= 0 && p2.life <= 0) {
                    winnerIdx = -1; // Draw
                } else if (p1.life <= 0) {
                    winnerIdx = 1;
                } else {
                    winnerIdx = 0;
                }
            }

            if (winnerIdx !== null) {
                overlay.classList.remove('hidden');
                overlay.classList.add('active');
                
                let winnerText = "";
                
                if (winnerIdx === -1) winnerText = "å¼•ãåˆ†ã‘";
                else winnerText = `ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ ${winnerIdx + 1} ã®å‹åˆ©ï¼`;

                document.getElementById('winner-text').innerText = winnerText;
                document.getElementById('win-reason').innerText = reason;
            }
        }

        function renderMana(id, val, max) {
            let h = '';
            for(let i=0; i<max; i++) {
                let active = i < val ? 'active' : '';
                h += `<div class="mana-pip ${active}"></div>`;
            }
            document.getElementById(id).innerHTML = h;
        }

        function createCardHTML(c, extraClass='', onclick='') {
            let color = 'gray';
            if(c.type==='A') color='red'; if(c.type==='B') color='blue'; if(c.type==='C') color='purple';
            return `
            <div class="card card-type-${c.type} ${extraClass}" ${onclick}>
                <div class="card-cost">${c.cost}</div>
                <div class="card-title text-${color}-400">${c.name}</div>
                <div class="card-art">${getIcon(c)}</div>
                <div class="card-desc">${c.text}</div>
            </div>`;
        }
        function getIcon(c) {
            if(c.effect==='win') return 'ğŸ‘‘';
            if(c.type==='A') return 'âš”ï¸';
            if(c.type==='B') return 'ğŸ›¡ï¸';
            return 'ğŸ”®';
        }

        // Particle BG
        const ctx = document.getElementById('bg-canvas').getContext('2d');
        let ps = Array(50).fill().map(() => ({x:Math.random()*innerWidth, y:Math.random()*innerHeight, s:Math.random()*2, dx:(Math.random()-.5)*.5, dy:-Math.random()*.5}));
        function loop() {
            ctx.clearRect(0,0,innerWidth,innerHeight);
            ctx.fillStyle='#d4af37';
            ps.forEach(p=>{
                p.x+=p.dx; p.y+=p.dy; if(p.y<0) p.y=innerHeight;
                ctx.beginPath(); ctx.arc(p.x,p.y,p.s,0,7); ctx.fill();
            });
            requestAnimationFrame(loop);
        }
        document.getElementById('bg-canvas').width=innerWidth; document.getElementById('bg-canvas').height=innerHeight;
        loop();

    </script>
</body>
</html>        
